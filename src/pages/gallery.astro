---
const title = 'Behangmotief 3D Gallery';
const description =
  'A personalized 3D photo gallery built from your Spotify top artists and Kevin Meyvaert photography.';
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{title}</title>
    <meta name="description" content={description} />
    <meta name="robots" content="noindex,follow" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <script is:inline define:vars={{ apiKey: import.meta.env.PUBLIC_POSTHOG_KEY, apiHost: import.meta.env.PUBLIC_POSTHOG_HOST }}>
      !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.crossOrigin="anonymous",p.async=!0,p.src=s.api_host+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys getNextSurveyStep onSessionId".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
      posthog.init(apiKey || '', {
        api_host: apiHost || 'https://eu.i.posthog.com',
        defaults: '2025-11-30'
      })
    </script>
  </head>
  <body>
    <main id="gallery-app">
      <div id="scene-root" aria-label="3D gallery scene"></div>

      <div id="lobby-shell" class="lobby-shell">
        <header class="lobby-header">
          <a class="lobby-brand" href="/nl/" aria-label="Behangmotief home">
            <img src="/logo.svg" alt="Behangmotief" />
            <span>music and festival photography</span>
          </a>
          <p class="lobby-kicker">Spotify Curated 3D Room</p>
        </header>

        <section id="auth-panel" class="overlay-panel">
          <p class="kicker">Behangmotief / Gallery</p>
          <h1>Walk Through Your Listening Universe</h1>
          <p id="status-text">
            Log in with Spotify to map your top artists to Kevin Meyvaert photo moments in a 3D space.
          </p>
          <div class="lobby-actions">
            <button id="spotify-login" class="cta-button">Login with Spotify</button>
            <button id="enter-gallery" class="enter-button hidden" type="button">Enter Gallery</button>
          </div>
          <p class="meta-note">
            Scope: <code>user-top-read</code> Â· keyboard navigation with mouse-look.
          </p>
          <p class="meta-note">
            Redirect URI: <code id="redirect-uri-label"></code>
          </p>
        </section>

        <section id="artists-panel" class="artists-panel hidden">
          <p class="panel-title">Matched from your Spotify profile</p>
          <ul id="artists-list"></ul>
        </section>
      </div>

      <p id="controls-hint" class="controls-hint hidden">
        Press Esc to leave
      </p>

      <div id="error-toast" class="error-toast hidden" role="status" aria-live="polite"></div>
    </main>

    <script>
      // @ts-nocheck
      import * as THREE from 'three';
      import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';
      import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
      import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
      import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

      const SPOTIFY_CLIENT_ID = import.meta.env.PUBLIC_SPOTIFY_CLIENT_ID;
      function normalizeRedirectUri(rawValue) {
        const value = String(rawValue || '').trim();
        if (!value) return '';

        const url = new URL(value);
        if (url.pathname.length > 1) {
          url.pathname = url.pathname.replace(/\/+$/, '');
        }
        url.search = '';
        url.hash = '';
        return url.toString();
      }

      const SPOTIFY_REDIRECT_URI = normalizeRedirectUri(
        import.meta.env.PUBLIC_SPOTIFY_REDIRECT_URI || `${window.location.origin}/gallery`
      );
      const SPOTIFY_SCOPE = 'user-top-read';
      const TOKEN_KEY = 'spotify_gallery_token';
      const PKCE_VERIFIER_KEY = 'spotify_gallery_pkce_verifier';
      const PKCE_STATE_KEY = 'spotify_gallery_pkce_state';

      const lobbyShell = document.getElementById('lobby-shell');
      const authPanel = document.getElementById('auth-panel');
      const statusText = document.getElementById('status-text');
      const loginButton = document.getElementById('spotify-login');
      const enterButton = document.getElementById('enter-gallery');
      const artistsPanel = document.getElementById('artists-panel');
      const artistsList = document.getElementById('artists-list');
      const controlsHint = document.getElementById('controls-hint');
      const errorToast = document.getElementById('error-toast');
      const sceneRoot = document.getElementById('scene-root');
      const redirectUriLabel = document.getElementById('redirect-uri-label');

      let disposeScene = () => {};

      if (redirectUriLabel) {
        redirectUriLabel.textContent = SPOTIFY_REDIRECT_URI || '(not set)';
      }

      class HttpError extends Error {
        constructor(message, status, details) {
          super(message);
          this.name = 'HttpError';
          this.status = status;
          this.details = details;
        }
      }

      function setStatus(text) {
        statusText.textContent = text;
      }

      function showError(message) {
        errorToast.textContent = message;
        errorToast.classList.remove('hidden');
        window.clearTimeout(showError.timeoutId);
        showError.timeoutId = window.setTimeout(() => {
          errorToast.classList.add('hidden');
        }, 6500);
      }
      showError.timeoutId = 0;

      function randomString(length = 64) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const bytes = new Uint8Array(length);
        crypto.getRandomValues(bytes);
        return Array.from(bytes, (value) => chars[value % chars.length]).join('');
      }

      async function createCodeChallenge(verifier) {
        const encoded = new TextEncoder().encode(verifier);
        const digest = await crypto.subtle.digest('SHA-256', encoded);
        const bytes = Array.from(new Uint8Array(digest));
        const binary = bytes.map((b) => String.fromCharCode(b)).join('');
        return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
      }

      function clearStoredAuth() {
        localStorage.removeItem(TOKEN_KEY);
        localStorage.removeItem(PKCE_VERIFIER_KEY);
        localStorage.removeItem(PKCE_STATE_KEY);
      }

      function readStoredToken() {
        const raw = localStorage.getItem(TOKEN_KEY);
        if (!raw) return null;

        try {
          const tokenData = JSON.parse(raw);
          if (!tokenData?.accessToken || !tokenData?.expiresAt) {
            clearStoredAuth();
            return null;
          }

          if (Date.now() >= tokenData.expiresAt) {
            clearStoredAuth();
            return null;
          }

          return tokenData.accessToken;
        } catch {
          clearStoredAuth();
          return null;
        }
      }

      function storeAccessToken(data) {
        const safetyBuffer = 30;
        const expiresAt = Date.now() + Math.max((data.expires_in || 3600) - safetyBuffer, 10) * 1000;
        localStorage.setItem(
          TOKEN_KEY,
          JSON.stringify({
            accessToken: data.access_token,
            expiresAt,
          })
        );
      }

      async function fetchJsonWithErrors(url, options = {}) {
        let response;
        try {
          response = await fetch(url, options);
        } catch (error) {
          throw new HttpError('Network request failed', 0, String(error));
        }

        let payload = null;
        const text = await response.text();
        if (text) {
          try {
            payload = JSON.parse(text);
          } catch {
            payload = null;
          }
        }

        if (!response.ok) {
          const details = payload?.error_description || payload?.error || payload?.details || text;
          throw new HttpError(`Request failed (${response.status})`, response.status, details);
        }

        return payload;
      }

      async function startSpotifyLogin() {
        if (!SPOTIFY_CLIENT_ID) {
          showError('Missing PUBLIC_SPOTIFY_CLIENT_ID environment variable.');
          return;
        }

        const verifier = randomString(96);
        const challenge = await createCodeChallenge(verifier);
        const state = randomString(24);

        localStorage.setItem(PKCE_VERIFIER_KEY, verifier);
        localStorage.setItem(PKCE_STATE_KEY, state);

        const params = new URLSearchParams({
          client_id: SPOTIFY_CLIENT_ID,
          response_type: 'code',
          redirect_uri: SPOTIFY_REDIRECT_URI,
          scope: SPOTIFY_SCOPE,
          code_challenge_method: 'S256',
          code_challenge: challenge,
          state,
        });

        window.location.assign(`https://accounts.spotify.com/authorize?${params.toString()}`);
      }

      async function exchangeCodeForToken(code) {
        const verifier = localStorage.getItem(PKCE_VERIFIER_KEY);
        if (!verifier) {
          throw new Error('Missing PKCE verifier. Please log in again.');
        }

        const body = new URLSearchParams({
          grant_type: 'authorization_code',
          code,
          redirect_uri: SPOTIFY_REDIRECT_URI,
          client_id: SPOTIFY_CLIENT_ID,
          code_verifier: verifier,
        });

        const tokenPayload = await fetchJsonWithErrors('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: {
            'content-type': 'application/x-www-form-urlencoded',
          },
          body: body.toString(),
        });

        if (!tokenPayload?.access_token) {
          throw new Error('Spotify token response did not include an access token.');
        }

        storeAccessToken(tokenPayload);
        localStorage.removeItem(PKCE_VERIFIER_KEY);
        localStorage.removeItem(PKCE_STATE_KEY);

        return tokenPayload.access_token;
      }

      async function resolveSpotifyToken() {
        const callbackUrl = new URL(window.location.href);
        const authCode = callbackUrl.searchParams.get('code');
        const callbackState = callbackUrl.searchParams.get('state');

        if (!authCode) {
          return readStoredToken();
        }

        const storedState = localStorage.getItem(PKCE_STATE_KEY);
        if (!storedState || storedState !== callbackState) {
          clearStoredAuth();
          throw new Error('Spotify state check failed. Please authenticate again.');
        }

        const accessToken = await exchangeCodeForToken(authCode);
        callbackUrl.searchParams.delete('code');
        callbackUrl.searchParams.delete('state');
        window.history.replaceState({}, '', callbackUrl.pathname);
        return accessToken;
      }

      async function fetchTopArtistsForRange(accessToken, timeRange, limit = 50) {
        const result = await fetchJsonWithErrors(
          `https://api.spotify.com/v1/me/top/artists?limit=${limit}&time_range=${timeRange}`,
          {
            headers: {
              authorization: `Bearer ${accessToken}`,
            },
          }
        );

        return Array.isArray(result?.items) ? result.items : [];
      }

      async function loadTopArtists(accessToken) {
        const [shortTerm, mediumTerm, longTerm] = await Promise.all([
          fetchTopArtistsForRange(accessToken, 'short_term', 50),
          fetchTopArtistsForRange(accessToken, 'medium_term', 50),
          fetchTopArtistsForRange(accessToken, 'long_term', 50),
        ]);

        const combined = [
          { items: shortTerm, weight: 1.0 },
          { items: mediumTerm, weight: 1.15 },
          { items: longTerm, weight: 1.25 },
        ];

        const byName = new Map();
        for (const group of combined) {
          group.items.forEach((artist, index) => {
            const name = artist?.name;
            if (!name) return;

            const rankScore = 100 - index;
            const popularity = typeof artist?.popularity === 'number' ? artist.popularity : 0;
            const score = rankScore * group.weight + popularity * 0.2;
            const current = byName.get(name);

            if (!current) {
              byName.set(name, {
                name,
                popularity,
                score,
              });
              return;
            }

            current.score += score;
            if (popularity > current.popularity) {
              current.popularity = popularity;
            }
          });
        }

        return Array.from(byName.values())
          .sort((a, b) => b.score - a.score)
          .slice(0, 40);
      }

      function getPerformanceProfile() {
        const qualityParam = new URLSearchParams(window.location.search).get('quality');
        const forcedTier =
          qualityParam === 'high' || qualityParam === 'medium' || qualityParam === 'low'
            ? qualityParam
            : null;
        const deviceMemory = Number(navigator.deviceMemory || 8);
        const cores = Number(navigator.hardwareConcurrency || 8);
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        const autoLow = prefersReducedMotion || deviceMemory <= 4 || cores <= 4;
        const low = forcedTier === 'low' || (!forcedTier && autoLow);
        const medium =
          forcedTier === 'medium' || (!forcedTier && !autoLow && (deviceMemory <= 8 || cores <= 8));

        if (low) {
          return {
            tier: 'low',
            label: 'performance',
            textureWidth: 900,
            textureHeight: 650,
            maxImages: 12,
            pixelRatioCap: 1,
            antialias: false,
            maxAnisotropy: 2,
            stripStep: 12,
            pendantCount: 8,
            frameLightStride: 0,
            enableCeilingPointLights: false,
            enablePendantPointLights: false,
            enableSceneAnimation: false,
            enableLightPulsing: false,
            enableBloom: false,
            bloomStrength: 0,
            bloomRadius: 0,
            bloomThreshold: 1,
          };
        }

        if (medium) {
          return {
            tier: 'medium',
            label: 'balanced',
            textureWidth: 1200,
            textureHeight: 860,
            maxImages: 18,
            pixelRatioCap: 1.25,
            antialias: false,
            maxAnisotropy: 4,
            stripStep: 10.5,
            pendantCount: 12,
            frameLightStride: 0,
            enableCeilingPointLights: true,
            enablePendantPointLights: false,
            enableSceneAnimation: true,
            enableLightPulsing: true,
            enableBloom: true,
            bloomStrength: 0.62,
            bloomRadius: 0.55,
            bloomThreshold: 0.9,
          };
        }

        return {
          tier: 'high',
          label: 'visual',
          textureWidth: 1400,
          textureHeight: 1000,
          maxImages: 24,
          pixelRatioCap: 1.5,
          antialias: true,
          maxAnisotropy: 8,
          stripStep: 8.8,
          pendantCount: 16,
          frameLightStride: 0,
          enableCeilingPointLights: true,
          enablePendantPointLights: true,
          enableSceneAnimation: true,
          enableLightPulsing: true,
          enableBloom: true,
          bloomStrength: 1.05,
          bloomRadius: 0.7,
          bloomThreshold: 0.88,
        };
      }

      async function loadGalleryImages(artistNames, profile) {
        // Get PostHog session and distinct ID for server-side correlation
        const sessionId = window.posthog?.get_session_id?.() || null;
        const distinctId = window.posthog?.get_distinct_id?.() || null;

        const payload = await fetchJsonWithErrors('/api/gallery-images', {
          method: 'POST',
          headers: {
            'content-type': 'application/json',
            'X-PostHog-Session-Id': sessionId || '',
            'X-PostHog-Distinct-Id': distinctId || '',
          },
          body: JSON.stringify({
            artists: artistNames,
            imageWidth: profile.textureWidth,
            imageHeight: profile.textureHeight,
          }),
        });

        return Array.isArray(payload?.images) ? payload.images : [];
      }

      function renderArtists(artists) {
        artistsList.innerHTML = '';
        for (const artist of artists) {
          const item = document.createElement('li');
          item.textContent = `${artist.name} (${artist.popularity})`;
          artistsList.appendChild(item);
        }
      }

      function createTagTexture(title, location, date) {
        const canvas = document.createElement('canvas');
        canvas.width = 900;
        canvas.height = 190;

        const ctx = canvas.getContext('2d');
        if (!ctx) return null;

        ctx.fillStyle = 'rgba(236, 233, 224, 0.84)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = 'rgba(52, 47, 36, 0.6)';
        ctx.lineWidth = 4;
        ctx.strokeRect(8, 8, canvas.width - 16, canvas.height - 16);

        ctx.fillStyle = '#2c281f';
        ctx.textAlign = 'center';
        ctx.font = '700 34px Georgia, "Times New Roman", serif';
        ctx.fillText(title.slice(0, 42), canvas.width / 2, 58);

        ctx.font = '500 25px "Trebuchet MS", "Segoe UI", sans-serif';
        ctx.fillText(location.slice(0, 42), canvas.width / 2, 108);

        ctx.font = '500 22px "Trebuchet MS", "Segoe UI", sans-serif';
        ctx.fillText(date, canvas.width / 2, 148);

        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.needsUpdate = true;
        return texture;
      }

      function createWoodFloorTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        if (!ctx) return null;

        ctx.fillStyle = '#7f5d41';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const plankCount = 18;
        const plankHeight = canvas.height / plankCount;
        for (let i = 0; i < plankCount; i += 1) {
          const y = i * plankHeight;
          const hueShift = (i % 3) * 6;
          ctx.fillStyle = `hsl(${28 + hueShift} 36% ${36 + (i % 4)}%)`;
          ctx.fillRect(0, y, canvas.width, plankHeight - 1);

          for (let j = 0; j < 22; j += 1) {
            const grainX = Math.random() * canvas.width;
            const grainY = y + Math.random() * plankHeight;
            const grainW = 22 + Math.random() * 52;
            const grainH = 1 + Math.random() * 1.4;
            ctx.fillStyle = `rgba(255,255,255,${0.02 + Math.random() * 0.04})`;
            ctx.fillRect(grainX, grainY, grainW, grainH);
          }
        }

        ctx.fillStyle = 'rgba(30, 20, 12, 0.26)';
        for (let i = 1; i < plankCount; i += 1) {
          const y = i * plankHeight;
          ctx.fillRect(0, y - 1, canvas.width, 2);
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(3.2, 9.4);
        texture.needsUpdate = true;
        return texture;
      }

      function createPlasterTexture(baseColor = '#efece5') {
        const canvas = document.createElement('canvas');
        canvas.width = 768;
        canvas.height = 768;
        const ctx = canvas.getContext('2d');
        if (!ctx) return null;

        ctx.fillStyle = baseColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let i = 0; i < 7000; i += 1) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const alpha = 0.01 + Math.random() * 0.03;
          const tone = 188 + Math.floor(Math.random() * 42);
          ctx.fillStyle = `rgba(${tone},${tone - 6},${tone - 10},${alpha})`;
          ctx.fillRect(x, y, 2, 2);
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(5.6, 2.3);
        texture.needsUpdate = true;
        return texture;
      }

      function createCeilingPanelTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        if (!ctx) return null;

        ctx.fillStyle = '#11151d';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const cell = 128;
        for (let y = 0; y < canvas.height; y += cell) {
          for (let x = 0; x < canvas.width; x += cell) {
            const isRaised = ((x / cell) + (y / cell)) % 2 === 0;
            ctx.fillStyle = isRaised ? '#1a1f29' : '#0f131b';
            ctx.fillRect(x + 2, y + 2, cell - 4, cell - 4);
            ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            ctx.strokeRect(x + 2, y + 2, cell - 4, cell - 4);
          }
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(2.8, 8.4);
        texture.needsUpdate = true;
        return texture;
      }

      function disposeMaterial(material) {
        if (!material) return;
        if (material.map) material.map.dispose();
        material.dispose();
      }

      function toProxyImageUrl(sourceUrl) {
        return `/api/gallery-image?url=${encodeURIComponent(sourceUrl)}`;
      }

      function initializeThreeScene(images, profile) {
        const container = sceneRoot;
        container.innerHTML = '';
        const visibleImages = images.slice(0, profile.maxImages);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#e7e6e2');
        scene.fog = new THREE.Fog('#eceae5', 28, 132);

        const camera = new THREE.PerspectiveCamera(74, container.clientWidth / container.clientHeight, 0.1, 120);
        camera.position.set(0, 1.72, 7);

        const renderer = new THREE.WebGLRenderer({
          antialias: profile.antialias,
          alpha: false,
          powerPreference: 'high-performance',
        });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, profile.pixelRatioCap));
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = profile.tier === 'high' ? 1.03 : 0.98;
        renderer.shadowMap.enabled = false;
        container.appendChild(renderer.domElement);
        const textureAnisotropy = Math.min(
          renderer.capabilities.getMaxAnisotropy(),
          profile.maxAnisotropy
        );

        let composer = null;
        if (profile.enableBloom) {
          composer = new EffectComposer(renderer);
          composer.addPass(new RenderPass(scene, camera));
          const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(container.clientWidth, container.clientHeight),
            profile.bloomStrength,
            profile.bloomRadius,
            profile.bloomThreshold
          );
          composer.addPass(bloomPass);
        }

        const controls = new PointerLockControls(camera, renderer.domElement);

        const ambientLight = new THREE.AmbientLight('#ffffff', 0.64);
        scene.add(ambientLight);

        const hemisphere = new THREE.HemisphereLight('#ffffff', '#c3b59f', 0.46);
        scene.add(hemisphere);

        const fillLight = new THREE.DirectionalLight('#fdf7ea', 0.4);
        fillLight.position.set(8, 14, 6);
        scene.add(fillLight);

        const corridorStart = 12;
        const rowCount = Math.max(1, Math.ceil(visibleImages.length / 2));
        const step = 7;
        const corridorEnd = -(rowCount - 1) * step - 14;
        const corridorMid = (corridorStart + corridorEnd) / 2;
        const corridorLength = corridorStart - corridorEnd;
        const hallWidth = 22;
        const wallHeight = 5.8;
        const ceilingHeight = 6.2;
        const wallHalf = 8.9;
        const animatedLights = [];
        const vibeLights = [];
        const vibeGlowMaterials = [];
        const enableVibeLights = profile.tier !== 'low';
        const decorLevel = profile.tier === 'high' ? 2 : profile.tier === 'medium' ? 1 : 0;
        const floorTexture = createWoodFloorTexture();
        const wallTexture = createPlasterTexture('#f1eee8');
        const backWallTexture = createPlasterTexture('#ebe7de');
        const ceilingTexture = createCeilingPanelTexture();

        if (enableVibeLights) {
          const cyanWash = new THREE.PointLight('#2fd9ff', profile.tier === 'high' ? 0.55 : 0.36, 42);
          cyanWash.position.set(-7.2, 3.5, corridorMid + corridorLength * 0.12);
          scene.add(cyanWash);
          vibeLights.push({
            light: cyanWash,
            base: profile.tier === 'high' ? 0.55 : 0.36,
            phase: 0.4,
            colorA: new THREE.Color('#30dfff'),
            colorB: new THREE.Color('#4f7cff'),
          });

          const magentaWash = new THREE.PointLight('#ff3d9a', profile.tier === 'high' ? 0.62 : 0.42, 44);
          magentaWash.position.set(7.4, 3.4, corridorMid - corridorLength * 0.1);
          scene.add(magentaWash);
          vibeLights.push({
            light: magentaWash,
            base: profile.tier === 'high' ? 0.62 : 0.42,
            phase: 1.2,
            colorA: new THREE.Color('#ff3b9d'),
            colorB: new THREE.Color('#c643ff'),
          });

          const accentBack = new THREE.PointLight('#74ffb5', profile.tier === 'high' ? 0.28 : 0.2, 26);
          accentBack.position.set(0, 2.8, corridorEnd + 2.4);
          scene.add(accentBack);
          vibeLights.push({
            light: accentBack,
            base: profile.tier === 'high' ? 0.28 : 0.2,
            phase: 2.4,
            colorA: new THREE.Color('#74ffb5'),
            colorB: new THREE.Color('#56e9ff'),
          });
        }

        const floor = new THREE.Mesh(
          new THREE.PlaneGeometry(hallWidth, corridorLength + 26),
          new THREE.MeshStandardMaterial({
            color: '#7b7064',
            map: floorTexture,
            roughness: 0.9,
            metalness: 0.05,
          })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, 0, corridorMid);
        floor.receiveShadow = true;
        scene.add(floor);

        const ceiling = new THREE.Mesh(
          new THREE.PlaneGeometry(hallWidth, corridorLength + 26),
          new THREE.MeshStandardMaterial({
            color: '#16181f',
            map: ceilingTexture,
            roughness: 0.95,
            metalness: 0.08,
          })
        );
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.set(0, ceilingHeight, corridorMid);
        scene.add(ceiling);

        const wallMaterial = new THREE.MeshStandardMaterial({
          color: '#f2efe8',
          map: wallTexture,
          roughness: 0.92,
          metalness: 0.02,
        });

        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(corridorLength + 8, wallHeight), wallMaterial);
        leftWall.position.set(-wallHalf, wallHeight / 2, corridorMid);
        leftWall.rotation.y = Math.PI / 2;
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(
          new THREE.PlaneGeometry(corridorLength + 8, wallHeight),
          wallMaterial.clone()
        );
        rightWall.position.set(wallHalf, wallHeight / 2, corridorMid);
        rightWall.rotation.y = -Math.PI / 2;
        scene.add(rightWall);

        const backWall = new THREE.Mesh(
          new THREE.PlaneGeometry(wallHalf * 2, wallHeight),
          new THREE.MeshStandardMaterial({
            color: '#f4f2eb',
            map: backWallTexture,
            roughness: 0.9,
            metalness: 0.02,
          })
        );
        backWall.position.set(0, wallHeight / 2, corridorEnd);
        backWall.rotation.y = Math.PI;
        scene.add(backWall);

        if (enableVibeLights) {
          const leftRailMaterial = new THREE.MeshStandardMaterial({
            color: '#19202f',
            emissive: '#1dd6ff',
            emissiveIntensity: profile.tier === 'high' ? 1.28 : 0.9,
            roughness: 0.42,
            metalness: 0.22,
          });
          const leftRail = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, corridorLength + 4), leftRailMaterial);
          leftRail.position.set(-wallHalf + 0.24, 4.9, corridorMid);
          scene.add(leftRail);
          vibeGlowMaterials.push({
            material: leftRailMaterial,
            base: profile.tier === 'high' ? 1.28 : 0.9,
            phase: 0.7,
            colorA: new THREE.Color('#1dd6ff'),
            colorB: new THREE.Color('#596bff'),
          });

          const rightRailMaterial = new THREE.MeshStandardMaterial({
            color: '#21192d',
            emissive: '#ff3c98',
            emissiveIntensity: profile.tier === 'high' ? 1.35 : 0.95,
            roughness: 0.42,
            metalness: 0.22,
          });
          const rightRail = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.08, corridorLength + 4),
            rightRailMaterial
          );
          rightRail.position.set(wallHalf - 0.24, 4.9, corridorMid);
          scene.add(rightRail);
          vibeGlowMaterials.push({
            material: rightRailMaterial,
            base: profile.tier === 'high' ? 1.35 : 0.95,
            phase: 1.5,
            colorA: new THREE.Color('#ff3c98'),
            colorB: new THREE.Color('#bf4eff'),
          });

          const topBlueMaterial = new THREE.MeshStandardMaterial({
            color: '#141d2f',
            emissive: '#2dd9ff',
            emissiveIntensity: profile.tier === 'high' ? 1.4 : 1.0,
            roughness: 0.28,
            metalness: 0.35,
          });
          const topBlueStrip = new THREE.Mesh(
            new THREE.BoxGeometry(corridorLength + 2.8, 0.11, 0.11),
            topBlueMaterial
          );
          topBlueStrip.position.set(-2.6, ceilingHeight - 0.22, corridorMid);
          topBlueStrip.rotation.y = Math.PI / 2;
          scene.add(topBlueStrip);
          vibeGlowMaterials.push({
            material: topBlueMaterial,
            base: profile.tier === 'high' ? 1.4 : 1.0,
            phase: 0.25,
            colorA: new THREE.Color('#2dd9ff'),
            colorB: new THREE.Color('#5c72ff'),
          });

          const topPinkMaterial = new THREE.MeshStandardMaterial({
            color: '#2a1527',
            emissive: '#ff3d9b',
            emissiveIntensity: profile.tier === 'high' ? 1.45 : 1.02,
            roughness: 0.28,
            metalness: 0.35,
          });
          const topPinkStrip = new THREE.Mesh(
            new THREE.BoxGeometry(corridorLength + 2.8, 0.11, 0.11),
            topPinkMaterial
          );
          topPinkStrip.position.set(2.6, ceilingHeight - 0.22, corridorMid);
          topPinkStrip.rotation.y = Math.PI / 2;
          scene.add(topPinkStrip);
          vibeGlowMaterials.push({
            material: topPinkMaterial,
            base: profile.tier === 'high' ? 1.45 : 1.02,
            phase: 1.05,
            colorA: new THREE.Color('#ff3d9b'),
            colorB: new THREE.Color('#b84dff'),
          });
        }

        const trimMaterial = new THREE.MeshStandardMaterial({
          color: '#c8c3b5',
          roughness: 0.7,
          metalness: 0.05,
        });
        const leftTrim = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.2, corridorLength + 8), trimMaterial);
        leftTrim.position.set(-wallHalf + 0.04, 0.1, corridorMid);
        const rightTrim = leftTrim.clone();
        rightTrim.position.x = wallHalf - 0.04;
        scene.add(leftTrim);
        scene.add(rightTrim);

        const beamMaterial = new THREE.MeshStandardMaterial({
          color: '#12141c',
          roughness: 0.9,
          metalness: 0.06,
        });
        const beamDepth = corridorLength + 20;
        for (const x of [-5.8, -1.9, 1.9, 5.8]) {
          const beam = new THREE.Mesh(new THREE.BoxGeometry(0.34, 0.36, beamDepth), beamMaterial);
          beam.position.set(x, ceilingHeight - 0.14, corridorMid);
          scene.add(beam);
        }
        for (let z = corridorStart + 2; z >= corridorEnd - 2; z -= 4.8) {
          const crossBeam = new THREE.Mesh(new THREE.BoxGeometry(hallWidth - 1.4, 0.3, 0.36), beamMaterial);
          crossBeam.position.set(0, ceilingHeight - 0.18, z);
          scene.add(crossBeam);
        }

        const columnMaterial = new THREE.MeshStandardMaterial({
          color: '#ddd9d0',
          roughness: 0.82,
          metalness: 0.02,
        });
        for (let z = corridorStart - 7; z >= corridorEnd + 7; z -= 14) {
          const colLeft = new THREE.Mesh(new THREE.BoxGeometry(0.55, ceilingHeight, 0.55), columnMaterial);
          colLeft.position.set(-3.4, ceilingHeight / 2, z);
          scene.add(colLeft);

          const colRight = colLeft.clone();
          colRight.position.x = 3.4;
          scene.add(colRight);
        }

        const addPlant = (x, z, scale = 1) => {
          const plantGroup = new THREE.Group();
          plantGroup.position.set(x, 0, z);

          const pot = new THREE.Mesh(
            new THREE.CylinderGeometry(0.22 * scale, 0.28 * scale, 0.36 * scale, 12),
            new THREE.MeshStandardMaterial({
              color: '#3a2f28',
              roughness: 0.75,
              metalness: 0.08,
            })
          );
          pot.position.y = 0.18 * scale;
          plantGroup.add(pot);

          const leafMaterial = new THREE.MeshStandardMaterial({
            color: '#4f8f66',
            emissive: '#163825',
            emissiveIntensity: enableVibeLights ? 0.22 : 0.08,
            roughness: 0.66,
            metalness: 0.02,
            side: THREE.DoubleSide,
          });

          for (let i = 0; i < 7; i += 1) {
            const leaf = new THREE.Mesh(new THREE.PlaneGeometry(0.12 * scale, 0.7 * scale), leafMaterial);
            leaf.position.y = 0.5 * scale + i * 0.03 * scale;
            leaf.rotation.y = (i / 7) * Math.PI * 2;
            leaf.rotation.z = -0.3 + (i % 3) * 0.12;
            plantGroup.add(leaf);
          }

          scene.add(plantGroup);
        };

        const createScreenMaterial = (accentA, accentB, label) => {
          const canvas = document.createElement('canvas');
          canvas.width = 1024;
          canvas.height = 576;
          const ctx = canvas.getContext('2d');
          if (!ctx) {
            return new THREE.MeshStandardMaterial({
              color: '#0d1120',
              emissive: accentA,
              emissiveIntensity: 0.8,
              roughness: 0.4,
              metalness: 0.2,
            });
          }

          const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
          gradient.addColorStop(0, '#090d16');
          gradient.addColorStop(1, '#141a2a');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          const glow = ctx.createRadialGradient(
            canvas.width * 0.72,
            canvas.height * 0.28,
            50,
            canvas.width * 0.72,
            canvas.height * 0.28,
            380
          );
          glow.addColorStop(0, accentA);
          glow.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = glow;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          const glow2 = ctx.createRadialGradient(
            canvas.width * 0.3,
            canvas.height * 0.7,
            30,
            canvas.width * 0.3,
            canvas.height * 0.7,
            300
          );
          glow2.addColorStop(0, accentB);
          glow2.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = glow2;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.strokeStyle = 'rgba(255,255,255,0.16)';
          ctx.lineWidth = 6;
          ctx.strokeRect(16, 16, canvas.width - 32, canvas.height - 32);
          ctx.fillStyle = 'rgba(237,242,255,0.92)';
          ctx.font = '600 52px "Trebuchet MS", sans-serif';
          ctx.fillText(label, 56, canvas.height - 72);

          const texture = new THREE.CanvasTexture(canvas);
          texture.colorSpace = THREE.SRGBColorSpace;
          texture.needsUpdate = true;
          return new THREE.MeshStandardMaterial({
            color: '#ffffff',
            map: texture,
            emissive: '#4257ff',
            emissiveIntensity: 0.42,
            roughness: 0.38,
            metalness: 0.14,
          });
        };

        if (decorLevel > 0) {
          const rug = new THREE.Mesh(
            new THREE.PlaneGeometry(5.2, 8.4),
            new THREE.MeshStandardMaterial({
              color: '#2c374a',
              roughness: 0.95,
              metalness: 0.02,
            })
          );
          rug.rotation.x = -Math.PI / 2;
          rug.position.set(0, 0.01, corridorStart - 7.5);
          scene.add(rug);

          const benchMaterial = new THREE.MeshStandardMaterial({
            color: '#cfc9bc',
            roughness: 0.74,
            metalness: 0.05,
          });
          const seatMaterial = new THREE.MeshStandardMaterial({
            color: '#5a4f44',
            roughness: 0.86,
            metalness: 0.03,
          });
          const benchPositions = [corridorStart - 5.8, corridorStart - 17.4];
          for (const z of benchPositions) {
            for (const side of [-1, 1]) {
              const bench = new THREE.Group();
              bench.position.set(side * 5.8, 0, z);
              bench.rotation.y = side === -1 ? Math.PI / 2 : -Math.PI / 2;

              const base = new THREE.Mesh(new THREE.BoxGeometry(1.7, 0.28, 0.56), benchMaterial);
              base.position.y = 0.24;
              bench.add(base);

              const seat = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.08, 0.62), seatMaterial);
              seat.position.y = 0.42;
              bench.add(seat);

              scene.add(bench);
            }
          }

          addPlant(-6.5, corridorStart - 1.7, 1.08);
          addPlant(6.6, corridorStart - 12.6, 1.18);
          if (decorLevel > 1) {
            addPlant(-6.7, corridorEnd + 4.2, 1.2);
          }

          const accentPanelMaterial = new THREE.MeshStandardMaterial({
            color: '#0d1020',
            emissive: '#5b24f2',
            emissiveIntensity: enableVibeLights ? 0.85 : 0.26,
            roughness: 0.5,
            metalness: 0.32,
          });
          const accentPanel = new THREE.Mesh(new THREE.PlaneGeometry(3.6, 1.1), accentPanelMaterial);
          accentPanel.position.set(0, 4.2, corridorEnd + 0.05);
          accentPanel.rotation.y = Math.PI;
          scene.add(accentPanel);
          vibeGlowMaterials.push({
            material: accentPanelMaterial,
            base: enableVibeLights ? 0.85 : 0.26,
            phase: 2.1,
            colorA: new THREE.Color('#4f24ff'),
            colorB: new THREE.Color('#ff2f9d'),
          });

          if (decorLevel > 1) {
            const sideDiscMaterial = new THREE.MeshStandardMaterial({
              color: '#171c2b',
              emissive: '#2ec8ff',
              emissiveIntensity: 0.9,
              roughness: 0.38,
              metalness: 0.25,
            });
            const discLeft = new THREE.Mesh(new THREE.CylinderGeometry(0.62, 0.62, 0.08, 24), sideDiscMaterial);
            discLeft.rotation.x = Math.PI / 2;
            discLeft.position.set(-wallHalf + 0.06, 4.15, corridorStart - 11.2);
            discLeft.rotation.z = Math.PI / 2;
            scene.add(discLeft);

            const discRight = discLeft.clone();
            discRight.position.x = wallHalf - 0.06;
            discRight.material = sideDiscMaterial.clone();
            discRight.material.emissive = new THREE.Color('#ff2f9d');
            scene.add(discRight);

            vibeGlowMaterials.push({
              material: sideDiscMaterial,
              base: 0.9,
              phase: 2.8,
              colorA: new THREE.Color('#2ec8ff'),
              colorB: new THREE.Color('#6f57ff'),
            });
            vibeGlowMaterials.push({
              material: discRight.material,
              base: 0.92,
              phase: 3.5,
              colorA: new THREE.Color('#ff2f9d'),
              colorB: new THREE.Color('#9e54ff'),
            });
          }

          const lounge = new THREE.Group();
          lounge.position.set(-1.1, 0, corridorStart - 4.4);

          const sofaMat = new THREE.MeshStandardMaterial({
            color: '#454a58',
            roughness: 0.82,
            metalness: 0.03,
          });
          const sofaSeat = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.54, 1.28), sofaMat);
          sofaSeat.position.set(-1.2, 0.33, 0);
          lounge.add(sofaSeat);
          const sofaBack = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.82, 0.24), sofaMat);
          sofaBack.position.set(-1.2, 0.74, -0.52);
          lounge.add(sofaBack);
          const sofaArm = new THREE.Mesh(new THREE.BoxGeometry(0.26, 0.72, 1.22), sofaMat);
          sofaArm.position.set(-2.74, 0.62, 0);
          lounge.add(sofaArm);

          const tableTop = new THREE.Mesh(
            new THREE.BoxGeometry(1.95, 0.12, 1.12),
            new THREE.MeshStandardMaterial({
              color: '#ddd7cb',
              roughness: 0.65,
              metalness: 0.08,
            })
          );
          tableTop.position.set(1, 0.46, -0.08);
          lounge.add(tableTop);

          const tableLeg = new THREE.Mesh(
            new THREE.BoxGeometry(0.18, 0.34, 0.18),
            new THREE.MeshStandardMaterial({
              color: '#8f8577',
              roughness: 0.7,
              metalness: 0.14,
            })
          );
          for (const lx of [-0.8, 0.8]) {
            for (const lz of [-0.44, 0.44]) {
              const leg = tableLeg.clone();
              leg.position.set(1 + lx, 0.23, -0.08 + lz);
              lounge.add(leg);
            }
          }

          const deskTop = new THREE.Mesh(
            new THREE.BoxGeometry(2.25, 0.1, 0.82),
            new THREE.MeshStandardMaterial({
              color: '#d9cfbe',
              roughness: 0.64,
              metalness: 0.06,
            })
          );
          deskTop.position.set(-2.8, 0.78, 2.55);
          deskTop.rotation.y = Math.PI / 2.6;
          lounge.add(deskTop);

          const monitor = new THREE.Mesh(
            new THREE.PlaneGeometry(1.32, 0.76),
            createScreenMaterial('#00b4ff', '#ff4aa7', 'vibe gallery')
          );
          monitor.position.set(-2.3, 1.45, 2.5);
          monitor.rotation.y = Math.PI / 2.52;
          lounge.add(monitor);

          const tv = new THREE.Mesh(
            new THREE.PlaneGeometry(2.5, 1.35),
            createScreenMaterial('#4e35ff', '#f83f9b', 'behangmotief')
          );
          tv.position.set(4.95, 1.66, 0.42);
          tv.rotation.y = -Math.PI / 2;
          lounge.add(tv);

          const deskLight = new THREE.PointLight('#38caff', 0.56, 7.4);
          deskLight.position.set(-2.4, 1.6, 2.4);
          lounge.add(deskLight);
          const tvLight = new THREE.PointLight('#ff4da5', 0.48, 7);
          tvLight.position.set(4.25, 1.55, 0.45);
          lounge.add(tvLight);
          vibeLights.push({
            light: deskLight,
            base: 0.56,
            phase: 4.2,
            colorA: new THREE.Color('#30dfff'),
            colorB: new THREE.Color('#5c4dff'),
          });
          vibeLights.push({
            light: tvLight,
            base: 0.48,
            phase: 4.8,
            colorA: new THREE.Color('#ff4da5'),
            colorB: new THREE.Color('#a84dff'),
          });

          scene.add(lounge);

          const neonBandMaterial = new THREE.MeshStandardMaterial({
            color: '#141925',
            emissive: '#23d7ff',
            emissiveIntensity: decorLevel > 1 ? 1.1 : 0.78,
            roughness: 0.36,
            metalness: 0.22,
          });
          const neonBand = new THREE.Mesh(new THREE.BoxGeometry(0.08, 2.5, 0.08), neonBandMaterial);
          neonBand.position.set(-wallHalf + 0.09, 3.1, corridorStart - 10.5);
          scene.add(neonBand);
          vibeGlowMaterials.push({
            material: neonBandMaterial,
            base: decorLevel > 1 ? 1.1 : 0.78,
            phase: 5.2,
            colorA: new THREE.Color('#23d7ff'),
            colorB: new THREE.Color('#7454ff'),
          });
        }

        const stripMaterial = new THREE.MeshStandardMaterial({
          color: '#f8f7f3',
          emissive: '#f2f5ff',
          emissiveIntensity: profile.enableLightPulsing ? 1.05 : 0.88,
          roughness: 0.36,
          metalness: 0.22,
        });
        for (let z = corridorStart + 1; z >= corridorEnd; z -= profile.stripStep) {
          const strip = new THREE.Mesh(new THREE.BoxGeometry(4.6, 0.08, 0.12), stripMaterial.clone());
          strip.position.set(0, ceilingHeight - 0.62, z);
          scene.add(strip);

          if (profile.enableCeilingPointLights) {
            const stripLight = new THREE.PointLight('#fff1d8', 0.35, 10);
            stripLight.position.set(0, ceilingHeight - 0.84, z);
            scene.add(stripLight);
            animatedLights.push({
              material: profile.enableLightPulsing ? strip.material : null,
              light: profile.enableLightPulsing ? stripLight : null,
              base: 0.92,
              phase: Math.random() * Math.PI * 2,
            });
          }
        }

        const sculptureGroup = new THREE.Group();
        sculptureGroup.position.set(0, ceilingHeight - 0.46, corridorMid + 4);
        scene.add(sculptureGroup);

        const canopy = new THREE.Mesh(
          new THREE.CylinderGeometry(0.8, 0.8, 0.08, 24),
          new THREE.MeshStandardMaterial({
            color: '#f0ece3',
            roughness: 0.5,
            metalness: 0.24,
          })
        );
        sculptureGroup.add(canopy);

        const pendants = [];
        for (let i = 0; i < profile.pendantCount; i += 1) {
          const phase = (i / profile.pendantCount) * Math.PI * 2;
          const radius = 0.4 + i * 0.11;
          const length = 0.9 + (i % 5) * 0.2;

          const pendant = new THREE.Group();
          pendant.position.set(Math.cos(phase) * radius, -0.03, Math.sin(phase) * radius);

          const wire = new THREE.Mesh(
            new THREE.CylinderGeometry(0.008, 0.008, length, 8),
            new THREE.MeshStandardMaterial({ color: '#b9bfc9', roughness: 0.4, metalness: 0.8 })
          );
          wire.position.y = -length / 2;
          pendant.add(wire);

          const bulb = new THREE.Mesh(
            new THREE.SphereGeometry(0.11, 16, 16),
            new THREE.MeshStandardMaterial({
              color: '#ffffff',
              emissive: '#d7e7ff',
              emissiveIntensity: 0.95,
              roughness: 0.2,
              metalness: 0.14,
            })
          );
          bulb.position.y = -length;
          pendant.add(bulb);

          let bulbLight = null;
          if (profile.enablePendantPointLights) {
            bulbLight = new THREE.PointLight('#dce8ff', 0.26, 3.2);
            bulbLight.position.y = -length;
            pendant.add(bulbLight);
          }

          pendants.push({
            group: pendant,
            baseX: pendant.position.x,
            baseY: pendant.position.y,
            baseZ: pendant.position.z,
            phase,
            material: bulb.material,
            light: bulbLight,
          });

          sculptureGroup.add(pendant);
        }

        let dustParticles = null;
        if (decorLevel > 0) {
          const particleCount = profile.tier === 'high' ? 280 : 180;
          const positions = new Float32Array(particleCount * 3);
          for (let i = 0; i < particleCount; i += 1) {
            const i3 = i * 3;
            positions[i3] = (Math.random() - 0.5) * (hallWidth - 1.6);
            positions[i3 + 1] = 0.6 + Math.random() * (ceilingHeight - 1.2);
            positions[i3 + 2] = corridorEnd + 2 + Math.random() * (corridorLength + 9);
          }

          const particleGeometry = new THREE.BufferGeometry();
          particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          const particleMaterial = new THREE.PointsMaterial({
            color: '#f6f0de',
            size: profile.tier === 'high' ? 0.03 : 0.024,
            transparent: true,
            opacity: 0.42,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
          });
          dustParticles = new THREE.Points(particleGeometry, particleMaterial);
          scene.add(dustParticles);
        }

        const textureLoader = new THREE.TextureLoader();
        textureLoader.setCrossOrigin('anonymous');
        const frameMaterial = new THREE.MeshStandardMaterial({
          color: '#3a342c',
          roughness: 0.54,
          metalness: 0.22,
        });

        for (let index = 0; index < visibleImages.length; index += 1) {
          const data = visibleImages[index];
          const side = index % 2 === 0 ? -1 : 1;
          const row = Math.floor(index / 2);
          const z = corridorStart - row * step;

          const frameGroup = new THREE.Group();
          frameGroup.position.set(side * (wallHalf - 0.14), 2.7, z);
          frameGroup.rotation.y = side === -1 ? Math.PI / 2 : -Math.PI / 2;

          const frameOuter = new THREE.Mesh(new THREE.BoxGeometry(3.2, 2.34, 0.16), frameMaterial.clone());
          frameOuter.position.z = -0.05;
          frameGroup.add(frameOuter);

          const artMaterial = new THREE.MeshBasicMaterial({
            color: '#1d1d1d',
          });
          const artMesh = new THREE.Mesh(new THREE.PlaneGeometry(2.98, 2.02), artMaterial);
          artMesh.position.z = 0.04;
          frameGroup.add(artMesh);

          textureLoader.load(
            toProxyImageUrl(data.imageUrl),
            (texture) => {
              const width = texture.image?.naturalWidth || texture.image?.width || 1;
              const height = texture.image?.naturalHeight || texture.image?.height || 1;
              const ratio = THREE.MathUtils.clamp(width / Math.max(height, 1), 0.65, 1.85);
              const pictureHeight = 1.98;
              const pictureWidth = pictureHeight * ratio;

              texture.colorSpace = THREE.SRGBColorSpace;
              texture.anisotropy = textureAnisotropy;
              texture.needsUpdate = true;

              artMesh.geometry.dispose();
              artMesh.geometry = new THREE.PlaneGeometry(pictureWidth, pictureHeight);
              artMaterial.map = texture;
              artMaterial.color = new THREE.Color('#ffffff');
              artMaterial.needsUpdate = true;
            },
            undefined,
            () => {
              artMaterial.color = new THREE.Color('#3f2e2e');
            }
          );

          const tagTexture = createTagTexture(data.title, data.location, data.date);
          if (tagTexture) {
            const tag = new THREE.Mesh(
              new THREE.PlaneGeometry(1.96, 0.42),
              new THREE.MeshBasicMaterial({
                map: tagTexture,
                transparent: true,
                opacity: 0.82,
              })
            );
            tag.position.set(0, -1.42, 0.06);
            tag.rotation.x = -0.03;
            frameGroup.add(tag);
          }

          if (profile.frameLightStride > 0 && index % profile.frameLightStride === 0) {
            const target = new THREE.Object3D();
            target.position.set(side * (wallHalf - 0.04), 2.66, z);
            scene.add(target);

            const frameLight = new THREE.SpotLight('#fff3d8', 0.78, 8.4, Math.PI / 8, 0.52);
            frameLight.position.set(side * (wallHalf - 1.9), ceilingHeight - 0.58, z + 0.25);
            frameLight.target = target;
            frameLight.castShadow = false;
            scene.add(frameLight);

            if (profile.enableLightPulsing) {
              animatedLights.push({
                material: null,
                light: frameLight,
                base: 0.78,
                phase: index * 0.3,
              });
            }
          }

          scene.add(frameGroup);
        }

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const movement = {
          forward: false,
          backward: false,
          left: false,
          right: false,
          sprint: false,
        };

        let rafId = 0;
        let previousTime = performance.now();
        const walkSpeedByTier = {
          low: 30,
          medium: 34,
          high: 38,
        };
        const walkSpeed = walkSpeedByTier[profile.tier] || 34;
        const sprintMultiplier = 1.55;
        const minX = -5.8;
        const maxX = 5.8;
        const minZ = corridorEnd + 2.4;
        const maxZ = corridorStart + 2.2;

        const onKeyDown = (event) => {
          switch (event.code) {
            case 'KeyW':
            case 'ArrowUp':
              movement.forward = true;
              break;
            case 'KeyS':
            case 'ArrowDown':
              movement.backward = true;
              break;
            case 'KeyA':
            case 'ArrowLeft':
              movement.left = true;
              break;
            case 'KeyD':
            case 'ArrowRight':
              movement.right = true;
              break;
            case 'ShiftLeft':
            case 'ShiftRight':
              movement.sprint = true;
              break;
            default:
              break;
          }
        };

        const onKeyUp = (event) => {
          switch (event.code) {
            case 'KeyW':
            case 'ArrowUp':
              movement.forward = false;
              break;
            case 'KeyS':
            case 'ArrowDown':
              movement.backward = false;
              break;
            case 'KeyA':
            case 'ArrowLeft':
              movement.left = false;
              break;
            case 'KeyD':
            case 'ArrowRight':
              movement.right = false;
              break;
            case 'ShiftLeft':
            case 'ShiftRight':
              movement.sprint = false;
              break;
            default:
              break;
          }
        };

        const onResize = () => {
          camera.aspect = container.clientWidth / container.clientHeight;
          camera.updateProjectionMatrix();
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, profile.pixelRatioCap));
          renderer.setSize(container.clientWidth, container.clientHeight);
          if (composer) {
            composer.setPixelRatio(Math.min(window.devicePixelRatio, profile.pixelRatioCap));
            composer.setSize(container.clientWidth, container.clientHeight);
          }
        };

        controls.addEventListener('lock', () => {
          lobbyShell.classList.add('hidden');
          controlsHint.textContent = 'Press Esc to leave';
          controlsHint.classList.remove('hidden');
          enterButton.classList.add('hidden');
        });

        controls.addEventListener('unlock', () => {
          lobbyShell.classList.remove('hidden');
          controlsHint.classList.add('hidden');
          enterButton.classList.remove('hidden');
        });

        const animate = () => {
          rafId = window.requestAnimationFrame(animate);

          const time = performance.now();
          const delta = (time - previousTime) / 1000;

          if (controls.isLocked) {
            velocity.x -= velocity.x * 8.5 * delta;
            velocity.z -= velocity.z * 8.5 * delta;
            direction.z = Number(movement.forward) - Number(movement.backward);
            direction.x = Number(movement.right) - Number(movement.left);
            direction.normalize();
            const movementSpeed = movement.sprint ? walkSpeed * sprintMultiplier : walkSpeed;

            if (movement.forward || movement.backward) {
              velocity.z -= direction.z * movementSpeed * delta;
            }

            if (movement.left || movement.right) {
              velocity.x -= direction.x * movementSpeed * delta;
            }

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            camera.position.x = THREE.MathUtils.clamp(camera.position.x, minX, maxX);
            camera.position.z = THREE.MathUtils.clamp(camera.position.z, minZ, maxZ);
            camera.position.y = 1.72;
          }

          if (profile.enableSceneAnimation || profile.enableLightPulsing) {
            const sceneTime = time * 0.001;

            if (dustParticles) {
              dustParticles.rotation.y = sceneTime * 0.018;
              dustParticles.position.y = Math.sin(sceneTime * 0.36) * 0.06;
            }

            if (profile.enableSceneAnimation) {
              sculptureGroup.rotation.y += delta * 0.1;
              for (const pendant of pendants) {
                pendant.group.position.x = pendant.baseX + Math.sin(sceneTime * 1.1 + pendant.phase) * 0.06;
                pendant.group.position.y = pendant.baseY + Math.sin(sceneTime * 1.8 + pendant.phase * 0.8) * 0.035;
                pendant.group.position.z = pendant.baseZ + Math.cos(sceneTime * 1.2 + pendant.phase) * 0.06;

                const glow = 0.8 + Math.sin(sceneTime * 2.1 + pendant.phase * 1.7) * 0.22;
                pendant.material.emissiveIntensity = glow;
                if (pendant.light) {
                  pendant.light.intensity = 0.18 + glow * 0.14;
                }
              }
            }

            if (profile.enableLightPulsing) {
              for (const dynamicLight of animatedLights) {
                const pulse = 0.84 + Math.sin(sceneTime * 1.4 + dynamicLight.phase) * 0.16;
                if (dynamicLight.material) {
                  dynamicLight.material.emissiveIntensity = dynamicLight.base * pulse;
                }
                if (dynamicLight.light) {
                  dynamicLight.light.intensity = dynamicLight.base * pulse;
                }
              }

              for (const vibeLight of vibeLights) {
                const pulse = 0.76 + Math.sin(sceneTime * 1.15 + vibeLight.phase) * 0.28;
                const colorMix = 0.5 + Math.sin(sceneTime * 0.72 + vibeLight.phase * 0.9) * 0.5;
                vibeLight.light.color.copy(vibeLight.colorA).lerp(vibeLight.colorB, colorMix);
                vibeLight.light.intensity = vibeLight.base * pulse;
              }

              for (const glow of vibeGlowMaterials) {
                const pulse = 0.74 + Math.sin(sceneTime * 1.2 + glow.phase) * 0.22;
                const colorMix = 0.5 + Math.sin(sceneTime * 0.7 + glow.phase) * 0.5;
                glow.material.emissive.copy(glow.colorA).lerp(glow.colorB, colorMix);
                glow.material.emissiveIntensity = glow.base * pulse;
              }
            }
          } else {
            for (const pendant of pendants) {
              pendant.material.emissiveIntensity = 0.78;
              if (pendant.light) {
                pendant.light.intensity = 0.22;
              }
            }

            if (dustParticles) {
              dustParticles.rotation.y += delta * 0.008;
            }

            for (const vibeLight of vibeLights) {
              vibeLight.light.color.copy(vibeLight.colorA);
              vibeLight.light.intensity = vibeLight.base * 0.82;
            }

            for (const glow of vibeGlowMaterials) {
              glow.material.emissive.copy(glow.colorA);
              glow.material.emissiveIntensity = glow.base * 0.84;
            }
          }

          previousTime = time;
          if (composer) {
            composer.render();
          } else {
            renderer.render(scene, camera);
          }
        };

        window.addEventListener('resize', onResize);
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        animate();

        enterButton.onclick = () => {
          // Track gallery entered event
          window.posthog?.capture('gallery_entered', {
            performance_tier: profile.tier,
            image_count: visibleImages.length
          });
          controls.lock();
        };

        return () => {
          window.cancelAnimationFrame(rafId);
          window.removeEventListener('resize', onResize);
          window.removeEventListener('keydown', onKeyDown);
          window.removeEventListener('keyup', onKeyUp);
          controls.disconnect();

          scene.traverse((object) => {
            if (!object.isMesh) return;
            if (object.geometry) object.geometry.dispose();

            if (Array.isArray(object.material)) {
              object.material.forEach((material) => disposeMaterial(material));
            } else {
              disposeMaterial(object.material);
            }
          });

          if (composer?.dispose) {
            composer.dispose();
          }
          renderer.dispose();
          container.innerHTML = '';
        };
      }

      async function bootstrap() {
        loginButton.addEventListener('click', () => {
          setStatus('Redirecting to Spotify login...');
          // Track Spotify login started event
          window.posthog?.capture('gallery_spotify_login_started');
          startSpotifyLogin().catch((error) => {
            showError(error instanceof Error ? error.message : 'Spotify login failed.');
          });
        });

        if (!SPOTIFY_CLIENT_ID) {
          setStatus('Set PUBLIC_SPOTIFY_CLIENT_ID in your environment to enable Spotify login.');
          loginButton.disabled = true;
          return;
        }

        let token;
        try {
          token = await resolveSpotifyToken();
        } catch (error) {
          setStatus('Spotify authentication failed. Please try logging in again.');
          showError(error instanceof Error ? error.message : 'Authentication error');
          clearStoredAuth();
          return;
        }

        if (!token) {
          setStatus('Log in with Spotify to unlock your personalized gallery.');
          return;
        }

        loginButton.classList.add('hidden');
        setStatus('Loading your top Spotify artists...');

        let artists = [];
        try {
          artists = await loadTopArtists(token);
        } catch (error) {
          const isAuthIssue = error instanceof HttpError && error.status === 401;
          if (isAuthIssue) {
            clearStoredAuth();
          }

          setStatus('Could not read Spotify profile data. Please authenticate again.');
          showError(error instanceof Error ? error.message : 'Spotify API error');
          loginButton.classList.remove('hidden');
          return;
        }

        const artistNames = artists.slice(0, 40).map((artist) => artist.name);
        renderArtists(artists);
        artistsPanel.classList.remove('hidden');

        const performanceProfile = getPerformanceProfile();
        setStatus(`Curating and mounting your photo selection (${performanceProfile.label} mode)...`);

        let images = [];
        try {
          images = await loadGalleryImages(artistNames, performanceProfile);
        } catch (error) {
          setStatus('Could not load gallery images.');
          showError(error instanceof Error ? error.message : 'Gallery API error');
          return;
        }

        if (!images.length) {
          setStatus('No matching photos were found for this listening profile yet.');
          return;
        }

        disposeScene();
        disposeScene = initializeThreeScene(images, performanceProfile);
        enterButton.classList.remove('hidden');
        authPanel.classList.add('ready');
        setStatus('Gallery ready. Click "Enter Gallery" to explore in first person.');
      }

      bootstrap().catch((error) => {
        showError(error instanceof Error ? error.message : 'Unexpected startup error.');
      });

      window.addEventListener('beforeunload', () => {
        disposeScene();
      });
    </script>
  </body>
</html>

<style>
  :global(html),
  :global(body) {
    margin: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: radial-gradient(circle at 16% 14%, #1c2538 0%, #0d1017 65%, #08090d 100%);
    color: #faf7ef;
    font-family: 'Trebuchet MS', 'Gill Sans', 'Segoe UI', sans-serif;
  }

  #gallery-app {
    position: relative;
    width: 100vw;
    height: 100vh;
    background:
      radial-gradient(circle at 82% 80%, rgb(99 56 164 / 12%), transparent 44%),
      radial-gradient(circle at 8% 16%, rgb(35 138 200 / 14%), transparent 36%);
  }

  #scene-root {
    width: 100%;
    height: 100%;
  }

  .lobby-shell {
    position: absolute;
    inset: 0;
    z-index: 30;
    display: grid;
    grid-template-rows: auto 1fr auto;
    gap: 1rem;
    padding: 1.4rem 1.4rem 1.6rem;
    pointer-events: none;
    background:
      linear-gradient(130deg, rgb(0 0 0 / 42%), rgb(0 0 0 / 24%) 45%, rgb(0 0 0 / 46%)),
      radial-gradient(circle at 16% 12%, rgb(141 51 255 / 20%), transparent 42%),
      radial-gradient(circle at 84% 88%, rgb(53 173 255 / 18%), transparent 48%);
  }

  .lobby-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
    pointer-events: auto;
  }

  .lobby-brand {
    display: inline-flex;
    align-items: center;
    gap: 0.6rem;
    text-decoration: none;
    color: #111;
    background: rgb(255 255 255 / 94%);
    border: 1px solid rgb(0 0 0 / 12%);
    border-radius: 999px;
    padding: 0.35rem 0.9rem 0.35rem 0.42rem;
  }

  .lobby-brand img {
    width: 2.1rem;
    height: auto;
    display: block;
  }

  .lobby-brand span {
    font-size: 0.79rem;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    color: #262116;
    white-space: nowrap;
  }

  .lobby-kicker {
    margin: 0;
    border: 1px solid rgb(255 255 255 / 24%);
    border-radius: 999px;
    background: rgb(11 15 24 / 58%);
    color: rgb(247 232 204 / 92%);
    font-size: 0.72rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    padding: 0.42rem 0.8rem;
    white-space: nowrap;
  }

  .overlay-panel {
    width: min(44rem, calc(100vw - 2.8rem));
    align-self: center;
    justify-self: center;
    border-radius: 1.2rem;
    border: 1px solid rgb(255 255 255 / 26%);
    background:
      linear-gradient(135deg, rgb(255 255 255 / 14%), rgb(255 255 255 / 7%)),
      linear-gradient(165deg, rgb(8 12 20 / 86%), rgb(9 11 18 / 76%));
    box-shadow: 0 26px 62px rgb(0 0 0 / 42%);
    padding: 1.5rem 1.6rem 1.25rem;
    pointer-events: auto;
    transition: opacity 300ms ease, transform 300ms ease;
  }

  .overlay-panel.ready {
    opacity: 0.92;
  }

  .kicker {
    margin: 0;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.18em;
    color: rgb(255 213 147 / 88%);
  }

  .overlay-panel h1 {
    margin: 0.45rem 0 0.75rem;
    font-size: clamp(1.55rem, 4vw, 2.35rem);
    line-height: 1.1;
    font-family: Georgia, 'Times New Roman', serif;
    color: #fff4dc;
  }

  #status-text {
    margin: 0;
    line-height: 1.42;
    color: rgb(226 233 248 / 90%);
    max-width: 40ch;
  }

  .lobby-actions {
    margin-top: 1.1rem;
    display: flex;
    flex-wrap: wrap;
    gap: 0.65rem;
    align-items: center;
  }

  .cta-button {
    border: 0;
    border-radius: 999px;
    padding: 0.72rem 1.15rem;
    font-size: 0.9rem;
    font-weight: 700;
    cursor: pointer;
    color: #111;
    background: linear-gradient(145deg, #fff0b8, #f0ba74);
    transition: transform 180ms ease, box-shadow 180ms ease;
    box-shadow: 0 8px 24px rgb(244 161 94 / 36%);
  }

  .cta-button:hover:enabled {
    transform: translateY(-2px);
  }

  .cta-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .meta-note {
    margin: 0.75rem 0 0;
    font-size: 0.76rem;
    color: rgb(176 189 216 / 76%);
  }

  .enter-button {
    border: 1px solid rgb(255 227 169 / 58%);
    border-radius: 999px;
    padding: 0.68rem 1.1rem;
    background: rgb(8 14 24 / 72%);
    color: #ffe8c0;
    font-size: 0.86rem;
    font-weight: 700;
    cursor: pointer;
    letter-spacing: 0.03em;
    transition: background 180ms ease, transform 180ms ease;
  }

  .enter-button:hover {
    background: rgb(11 20 34 / 84%);
    transform: translateY(-1px);
  }

  .artists-panel {
    justify-self: end;
    align-self: end;
    width: min(21rem, calc(100vw - 2.8rem));
    padding: 0.78rem 0.86rem;
    border-radius: 0.9rem;
    border: 1px solid rgb(255 255 255 / 18%);
    background: linear-gradient(165deg, rgb(8 12 20 / 78%), rgb(10 14 24 / 72%));
    backdrop-filter: blur(3px);
    max-height: min(44vh, 21rem);
    overflow: auto;
    pointer-events: auto;
  }

  .panel-title {
    margin: 0;
    font-size: 0.69rem;
    text-transform: uppercase;
    letter-spacing: 0.13em;
    color: rgb(255 208 140 / 86%);
  }

  #artists-list {
    margin: 0.56rem 0 0;
    padding: 0;
    list-style: none;
    display: grid;
    gap: 0.32rem;
  }

  #artists-list li {
    border: 1px solid rgb(255 255 255 / 10%);
    border-radius: 0.5rem;
    padding: 0.33rem 0.47rem;
    font-size: 0.8rem;
    background: rgb(0 0 0 / 18%);
    color: rgb(232 239 255 / 92%);
  }

  .controls-hint {
    position: absolute;
    left: 50%;
    bottom: 1rem;
    transform: translateX(-50%);
    margin: 0;
    border-radius: 999px;
    padding: 0.48rem 0.8rem;
    border: 1px solid rgb(255 255 255 / 22%);
    background: rgb(7 11 20 / 66%);
    color: #fff2d6;
    font-size: 0.8rem;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    z-index: 35;
  }

  .error-toast {
    position: absolute;
    left: 50%;
    top: 1rem;
    transform: translateX(-50%);
    width: min(90vw, 32rem);
    border-radius: 0.8rem;
    border: 1px solid rgb(255 136 136 / 48%);
    padding: 0.6rem 0.8rem;
    background: rgb(54 11 16 / 89%);
    color: #ffe4e4;
    font-size: 0.86rem;
    z-index: 45;
  }

  .hidden {
    display: none !important;
  }

  @media (max-width: 860px) {
    .lobby-shell {
      padding: 0.85rem 0.85rem 1.1rem;
      gap: 0.7rem;
    }

    .lobby-header {
      align-items: flex-start;
      flex-direction: column;
      gap: 0.55rem;
    }

    .lobby-brand span {
      font-size: 0.68rem;
      letter-spacing: 0.05em;
    }

    .overlay-panel {
      width: calc(100vw - 1.7rem);
      padding: 1.1rem 1rem 0.95rem;
      border-radius: 1rem;
    }

    .overlay-panel h1 {
      font-size: clamp(1.3rem, 7.2vw, 1.78rem);
    }

    .lobby-actions {
      width: 100%;
    }

    .cta-button,
    .enter-button {
      width: 100%;
      text-align: center;
    }

    .artists-panel {
      width: calc(100vw - 1.7rem);
      max-height: 30vh;
      justify-self: center;
      border-radius: 0.8rem;
    }

    .controls-hint {
      width: calc(100vw - 1.7rem);
      border-radius: 0.72rem;
      text-align: center;
      line-height: 1.35;
    }
  }
</style>
