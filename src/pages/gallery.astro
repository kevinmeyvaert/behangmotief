---
const title = 'Behangmotief 3D Gallery';
const description =
  'A personalized 3D photo gallery built from your Spotify top artists and Kevin Meyvaert photography.';
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{title}</title>
    <meta name="description" content={description} />
    <meta name="robots" content="noindex,follow" />
    <link rel="icon" type="image/png" href="/favicon.png" />
  </head>
  <body>
    <main id="gallery-app">
      <div id="scene-root" aria-label="3D gallery scene"></div>

      <section id="auth-panel" class="overlay-panel">
        <p class="kicker">Behangmotief / Gallery</p>
        <h1>Connect Spotify To Enter</h1>
        <p id="status-text">
          Log in with Spotify so the gallery can be curated around your favorite artists.
        </p>
        <button id="spotify-login" class="cta-button">Login with Spotify</button>
        <p class="meta-note">
          Scope used: <code>user-top-read</code>. No Spotify password is handled here.
        </p>
        <p class="meta-note">
          Redirect URI: <code id="redirect-uri-label"></code>
        </p>
      </section>

      <button id="enter-gallery" class="enter-button hidden" type="button">Enter Gallery</button>

      <section id="artists-panel" class="artists-panel hidden">
        <p class="panel-title">Top Artists</p>
        <ul id="artists-list"></ul>
      </section>

      <p id="controls-hint" class="controls-hint hidden">
        Press Esc to leave
      </p>

      <div id="error-toast" class="error-toast hidden" role="status" aria-live="polite"></div>
    </main>

    <script>
      // @ts-nocheck
      import * as THREE from 'three';
      import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';

      const SPOTIFY_CLIENT_ID = import.meta.env.PUBLIC_SPOTIFY_CLIENT_ID;
      function normalizeRedirectUri(rawValue) {
        const value = String(rawValue || '').trim();
        if (!value) return '';

        const url = new URL(value);
        if (url.pathname.length > 1) {
          url.pathname = url.pathname.replace(/\/+$/, '');
        }
        url.search = '';
        url.hash = '';
        return url.toString();
      }

      const SPOTIFY_REDIRECT_URI = normalizeRedirectUri(
        import.meta.env.PUBLIC_SPOTIFY_REDIRECT_URI || `${window.location.origin}/gallery`
      );
      const SPOTIFY_SCOPE = 'user-top-read';
      const TOKEN_KEY = 'spotify_gallery_token';
      const PKCE_VERIFIER_KEY = 'spotify_gallery_pkce_verifier';
      const PKCE_STATE_KEY = 'spotify_gallery_pkce_state';

      const authPanel = document.getElementById('auth-panel');
      const statusText = document.getElementById('status-text');
      const loginButton = document.getElementById('spotify-login');
      const enterButton = document.getElementById('enter-gallery');
      const artistsPanel = document.getElementById('artists-panel');
      const artistsList = document.getElementById('artists-list');
      const controlsHint = document.getElementById('controls-hint');
      const errorToast = document.getElementById('error-toast');
      const sceneRoot = document.getElementById('scene-root');
      const redirectUriLabel = document.getElementById('redirect-uri-label');

      let disposeScene = () => {};

      if (redirectUriLabel) {
        redirectUriLabel.textContent = SPOTIFY_REDIRECT_URI || '(not set)';
      }

      class HttpError extends Error {
        constructor(message, status, details) {
          super(message);
          this.name = 'HttpError';
          this.status = status;
          this.details = details;
        }
      }

      function setStatus(text) {
        statusText.textContent = text;
      }

      function showError(message) {
        errorToast.textContent = message;
        errorToast.classList.remove('hidden');
        window.clearTimeout(showError.timeoutId);
        showError.timeoutId = window.setTimeout(() => {
          errorToast.classList.add('hidden');
        }, 6500);
      }
      showError.timeoutId = 0;

      function randomString(length = 64) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const bytes = new Uint8Array(length);
        crypto.getRandomValues(bytes);
        return Array.from(bytes, (value) => chars[value % chars.length]).join('');
      }

      async function createCodeChallenge(verifier) {
        const encoded = new TextEncoder().encode(verifier);
        const digest = await crypto.subtle.digest('SHA-256', encoded);
        const bytes = Array.from(new Uint8Array(digest));
        const binary = bytes.map((b) => String.fromCharCode(b)).join('');
        return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
      }

      function clearStoredAuth() {
        localStorage.removeItem(TOKEN_KEY);
        localStorage.removeItem(PKCE_VERIFIER_KEY);
        localStorage.removeItem(PKCE_STATE_KEY);
      }

      function readStoredToken() {
        const raw = localStorage.getItem(TOKEN_KEY);
        if (!raw) return null;

        try {
          const tokenData = JSON.parse(raw);
          if (!tokenData?.accessToken || !tokenData?.expiresAt) {
            clearStoredAuth();
            return null;
          }

          if (Date.now() >= tokenData.expiresAt) {
            clearStoredAuth();
            return null;
          }

          return tokenData.accessToken;
        } catch {
          clearStoredAuth();
          return null;
        }
      }

      function storeAccessToken(data) {
        const safetyBuffer = 30;
        const expiresAt = Date.now() + Math.max((data.expires_in || 3600) - safetyBuffer, 10) * 1000;
        localStorage.setItem(
          TOKEN_KEY,
          JSON.stringify({
            accessToken: data.access_token,
            expiresAt,
          })
        );
      }

      async function fetchJsonWithErrors(url, options = {}) {
        let response;
        try {
          response = await fetch(url, options);
        } catch (error) {
          throw new HttpError('Network request failed', 0, String(error));
        }

        let payload = null;
        const text = await response.text();
        if (text) {
          try {
            payload = JSON.parse(text);
          } catch {
            payload = null;
          }
        }

        if (!response.ok) {
          const details = payload?.error_description || payload?.error || payload?.details || text;
          throw new HttpError(`Request failed (${response.status})`, response.status, details);
        }

        return payload;
      }

      async function startSpotifyLogin() {
        if (!SPOTIFY_CLIENT_ID) {
          showError('Missing PUBLIC_SPOTIFY_CLIENT_ID environment variable.');
          return;
        }

        const verifier = randomString(96);
        const challenge = await createCodeChallenge(verifier);
        const state = randomString(24);

        localStorage.setItem(PKCE_VERIFIER_KEY, verifier);
        localStorage.setItem(PKCE_STATE_KEY, state);

        const params = new URLSearchParams({
          client_id: SPOTIFY_CLIENT_ID,
          response_type: 'code',
          redirect_uri: SPOTIFY_REDIRECT_URI,
          scope: SPOTIFY_SCOPE,
          code_challenge_method: 'S256',
          code_challenge: challenge,
          state,
        });

        window.location.assign(`https://accounts.spotify.com/authorize?${params.toString()}`);
      }

      async function exchangeCodeForToken(code) {
        const verifier = localStorage.getItem(PKCE_VERIFIER_KEY);
        if (!verifier) {
          throw new Error('Missing PKCE verifier. Please log in again.');
        }

        const body = new URLSearchParams({
          grant_type: 'authorization_code',
          code,
          redirect_uri: SPOTIFY_REDIRECT_URI,
          client_id: SPOTIFY_CLIENT_ID,
          code_verifier: verifier,
        });

        const tokenPayload = await fetchJsonWithErrors('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: {
            'content-type': 'application/x-www-form-urlencoded',
          },
          body: body.toString(),
        });

        if (!tokenPayload?.access_token) {
          throw new Error('Spotify token response did not include an access token.');
        }

        storeAccessToken(tokenPayload);
        localStorage.removeItem(PKCE_VERIFIER_KEY);
        localStorage.removeItem(PKCE_STATE_KEY);

        return tokenPayload.access_token;
      }

      async function resolveSpotifyToken() {
        const callbackUrl = new URL(window.location.href);
        const authCode = callbackUrl.searchParams.get('code');
        const callbackState = callbackUrl.searchParams.get('state');

        if (!authCode) {
          return readStoredToken();
        }

        const storedState = localStorage.getItem(PKCE_STATE_KEY);
        if (!storedState || storedState !== callbackState) {
          clearStoredAuth();
          throw new Error('Spotify state check failed. Please authenticate again.');
        }

        const accessToken = await exchangeCodeForToken(authCode);
        callbackUrl.searchParams.delete('code');
        callbackUrl.searchParams.delete('state');
        window.history.replaceState({}, '', callbackUrl.pathname);
        return accessToken;
      }

      async function fetchTopArtistsForRange(accessToken, timeRange, limit = 50) {
        const result = await fetchJsonWithErrors(
          `https://api.spotify.com/v1/me/top/artists?limit=${limit}&time_range=${timeRange}`,
          {
            headers: {
              authorization: `Bearer ${accessToken}`,
            },
          }
        );

        return Array.isArray(result?.items) ? result.items : [];
      }

      async function loadTopArtists(accessToken) {
        const [shortTerm, mediumTerm, longTerm] = await Promise.all([
          fetchTopArtistsForRange(accessToken, 'short_term', 50),
          fetchTopArtistsForRange(accessToken, 'medium_term', 50),
          fetchTopArtistsForRange(accessToken, 'long_term', 50),
        ]);

        const combined = [
          { items: shortTerm, weight: 1.0 },
          { items: mediumTerm, weight: 1.15 },
          { items: longTerm, weight: 1.25 },
        ];

        const byName = new Map();
        for (const group of combined) {
          group.items.forEach((artist, index) => {
            const name = artist?.name;
            if (!name) return;

            const rankScore = 100 - index;
            const popularity = typeof artist?.popularity === 'number' ? artist.popularity : 0;
            const score = rankScore * group.weight + popularity * 0.2;
            const current = byName.get(name);

            if (!current) {
              byName.set(name, {
                name,
                popularity,
                score,
              });
              return;
            }

            current.score += score;
            if (popularity > current.popularity) {
              current.popularity = popularity;
            }
          });
        }

        return Array.from(byName.values())
          .sort((a, b) => b.score - a.score)
          .slice(0, 40);
      }

      function getPerformanceProfile() {
        const deviceMemory = Number(navigator.deviceMemory || 8);
        const cores = Number(navigator.hardwareConcurrency || 8);
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        const low = prefersReducedMotion || deviceMemory <= 4 || cores <= 4;
        const medium = !low && (deviceMemory <= 8 || cores <= 8);

        if (low) {
          return {
            tier: 'low',
            label: 'performance',
            textureWidth: 900,
            textureHeight: 650,
            maxImages: 12,
            pixelRatioCap: 1,
            antialias: false,
            maxAnisotropy: 2,
            stripStep: 12,
            pendantCount: 8,
            frameLightStride: 0,
            enableCeilingPointLights: false,
            enablePendantPointLights: false,
            enableSceneAnimation: false,
            enableLightPulsing: false,
          };
        }

        if (medium) {
          return {
            tier: 'medium',
            label: 'balanced',
            textureWidth: 1200,
            textureHeight: 860,
            maxImages: 18,
            pixelRatioCap: 1.25,
            antialias: false,
            maxAnisotropy: 4,
            stripStep: 10.5,
            pendantCount: 12,
            frameLightStride: 4,
            enableCeilingPointLights: true,
            enablePendantPointLights: false,
            enableSceneAnimation: true,
            enableLightPulsing: true,
          };
        }

        return {
          tier: 'high',
          label: 'visual',
          textureWidth: 1400,
          textureHeight: 1000,
          maxImages: 24,
          pixelRatioCap: 1.5,
          antialias: true,
          maxAnisotropy: 8,
          stripStep: 8.8,
          pendantCount: 16,
          frameLightStride: 3,
          enableCeilingPointLights: true,
          enablePendantPointLights: true,
          enableSceneAnimation: true,
          enableLightPulsing: true,
        };
      }

      async function loadGalleryImages(artistNames, profile) {
        const payload = await fetchJsonWithErrors('/api/gallery-images', {
          method: 'POST',
          headers: {
            'content-type': 'application/json',
          },
          body: JSON.stringify({
            artists: artistNames,
            imageWidth: profile.textureWidth,
            imageHeight: profile.textureHeight,
          }),
        });

        return Array.isArray(payload?.images) ? payload.images : [];
      }

      function renderArtists(artists) {
        artistsList.innerHTML = '';
        for (const artist of artists) {
          const item = document.createElement('li');
          item.textContent = `${artist.name} (${artist.popularity})`;
          artistsList.appendChild(item);
        }
      }

      function createTagTexture(title, location, date) {
        const canvas = document.createElement('canvas');
        canvas.width = 900;
        canvas.height = 190;

        const ctx = canvas.getContext('2d');
        if (!ctx) return null;

        ctx.fillStyle = 'rgba(236, 233, 224, 0.84)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = 'rgba(52, 47, 36, 0.6)';
        ctx.lineWidth = 4;
        ctx.strokeRect(8, 8, canvas.width - 16, canvas.height - 16);

        ctx.fillStyle = '#2c281f';
        ctx.textAlign = 'center';
        ctx.font = '700 34px Georgia, "Times New Roman", serif';
        ctx.fillText(title.slice(0, 42), canvas.width / 2, 58);

        ctx.font = '500 25px "Trebuchet MS", "Segoe UI", sans-serif';
        ctx.fillText(location.slice(0, 42), canvas.width / 2, 108);

        ctx.font = '500 22px "Trebuchet MS", "Segoe UI", sans-serif';
        ctx.fillText(date, canvas.width / 2, 148);

        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.needsUpdate = true;
        return texture;
      }

      function disposeMaterial(material) {
        if (!material) return;
        if (material.map) material.map.dispose();
        material.dispose();
      }

      function toProxyImageUrl(sourceUrl) {
        return `/api/gallery-image?url=${encodeURIComponent(sourceUrl)}`;
      }

      function initializeThreeScene(images, profile) {
        const container = sceneRoot;
        container.innerHTML = '';
        const visibleImages = images.slice(0, profile.maxImages);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#e7e6e2');
        scene.fog = new THREE.Fog('#eceae5', 28, 132);

        const camera = new THREE.PerspectiveCamera(74, container.clientWidth / container.clientHeight, 0.1, 120);
        camera.position.set(0, 1.72, 7);

        const renderer = new THREE.WebGLRenderer({
          antialias: profile.antialias,
          alpha: false,
          powerPreference: 'high-performance',
        });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, profile.pixelRatioCap));
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = false;
        container.appendChild(renderer.domElement);
        const textureAnisotropy = Math.min(
          renderer.capabilities.getMaxAnisotropy(),
          profile.maxAnisotropy
        );

        const controls = new PointerLockControls(camera, renderer.domElement);

        const ambientLight = new THREE.AmbientLight('#ffffff', 0.64);
        scene.add(ambientLight);

        const hemisphere = new THREE.HemisphereLight('#ffffff', '#c3b59f', 0.46);
        scene.add(hemisphere);

        const fillLight = new THREE.DirectionalLight('#fdf7ea', 0.4);
        fillLight.position.set(8, 14, 6);
        scene.add(fillLight);

        const corridorStart = 12;
        const rowCount = Math.max(1, Math.ceil(visibleImages.length / 2));
        const step = 7;
        const corridorEnd = -(rowCount - 1) * step - 14;
        const corridorMid = (corridorStart + corridorEnd) / 2;
        const corridorLength = corridorStart - corridorEnd;
        const hallWidth = 22;
        const wallHeight = 5.8;
        const ceilingHeight = 6.2;
        const wallHalf = 8.9;
        const animatedLights = [];

        const floor = new THREE.Mesh(
          new THREE.PlaneGeometry(hallWidth, corridorLength + 26),
          new THREE.MeshStandardMaterial({
            color: '#7b7064',
            roughness: 0.9,
            metalness: 0.05,
          })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, 0, corridorMid);
        floor.receiveShadow = true;
        scene.add(floor);

        const ceiling = new THREE.Mesh(
          new THREE.PlaneGeometry(hallWidth, corridorLength + 26),
          new THREE.MeshStandardMaterial({
            color: '#16181f',
            roughness: 0.95,
            metalness: 0.08,
          })
        );
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.set(0, ceilingHeight, corridorMid);
        scene.add(ceiling);

        const wallMaterial = new THREE.MeshStandardMaterial({
          color: '#f2efe8',
          roughness: 0.92,
          metalness: 0.02,
        });

        const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(corridorLength + 8, wallHeight), wallMaterial);
        leftWall.position.set(-wallHalf, wallHeight / 2, corridorMid);
        leftWall.rotation.y = Math.PI / 2;
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(
          new THREE.PlaneGeometry(corridorLength + 8, wallHeight),
          wallMaterial.clone()
        );
        rightWall.position.set(wallHalf, wallHeight / 2, corridorMid);
        rightWall.rotation.y = -Math.PI / 2;
        scene.add(rightWall);

        const backWall = new THREE.Mesh(
          new THREE.PlaneGeometry(wallHalf * 2, wallHeight),
          new THREE.MeshStandardMaterial({
            color: '#f4f2eb',
            roughness: 0.9,
            metalness: 0.02,
          })
        );
        backWall.position.set(0, wallHeight / 2, corridorEnd);
        backWall.rotation.y = Math.PI;
        scene.add(backWall);

        const trimMaterial = new THREE.MeshStandardMaterial({
          color: '#c8c3b5',
          roughness: 0.7,
          metalness: 0.05,
        });
        const leftTrim = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.2, corridorLength + 8), trimMaterial);
        leftTrim.position.set(-wallHalf + 0.04, 0.1, corridorMid);
        const rightTrim = leftTrim.clone();
        rightTrim.position.x = wallHalf - 0.04;
        scene.add(leftTrim);
        scene.add(rightTrim);

        const beamMaterial = new THREE.MeshStandardMaterial({
          color: '#12141c',
          roughness: 0.9,
          metalness: 0.06,
        });
        const beamDepth = corridorLength + 20;
        for (const x of [-5.8, -1.9, 1.9, 5.8]) {
          const beam = new THREE.Mesh(new THREE.BoxGeometry(0.34, 0.36, beamDepth), beamMaterial);
          beam.position.set(x, ceilingHeight - 0.14, corridorMid);
          scene.add(beam);
        }
        for (let z = corridorStart + 2; z >= corridorEnd - 2; z -= 4.8) {
          const crossBeam = new THREE.Mesh(new THREE.BoxGeometry(hallWidth - 1.4, 0.3, 0.36), beamMaterial);
          crossBeam.position.set(0, ceilingHeight - 0.18, z);
          scene.add(crossBeam);
        }

        const columnMaterial = new THREE.MeshStandardMaterial({
          color: '#ddd9d0',
          roughness: 0.82,
          metalness: 0.02,
        });
        for (let z = corridorStart - 7; z >= corridorEnd + 7; z -= 14) {
          const colLeft = new THREE.Mesh(new THREE.BoxGeometry(0.55, ceilingHeight, 0.55), columnMaterial);
          colLeft.position.set(-3.4, ceilingHeight / 2, z);
          scene.add(colLeft);

          const colRight = colLeft.clone();
          colRight.position.x = 3.4;
          scene.add(colRight);
        }

        const stripMaterial = new THREE.MeshStandardMaterial({
          color: '#f8f7f3',
          emissive: '#f2f5ff',
          emissiveIntensity: profile.enableLightPulsing ? 1.05 : 0.88,
          roughness: 0.36,
          metalness: 0.22,
        });
        for (let z = corridorStart + 1; z >= corridorEnd; z -= profile.stripStep) {
          const strip = new THREE.Mesh(new THREE.BoxGeometry(4.6, 0.08, 0.12), stripMaterial.clone());
          strip.position.set(0, ceilingHeight - 0.62, z);
          scene.add(strip);

          if (profile.enableCeilingPointLights) {
            const stripLight = new THREE.PointLight('#fff1d8', 0.35, 10);
            stripLight.position.set(0, ceilingHeight - 0.84, z);
            scene.add(stripLight);
            animatedLights.push({
              material: profile.enableLightPulsing ? strip.material : null,
              light: profile.enableLightPulsing ? stripLight : null,
              base: 0.92,
              phase: Math.random() * Math.PI * 2,
            });
          }
        }

        const sculptureGroup = new THREE.Group();
        sculptureGroup.position.set(0, ceilingHeight - 0.46, corridorMid + 4);
        scene.add(sculptureGroup);

        const canopy = new THREE.Mesh(
          new THREE.CylinderGeometry(0.8, 0.8, 0.08, 24),
          new THREE.MeshStandardMaterial({
            color: '#f0ece3',
            roughness: 0.5,
            metalness: 0.24,
          })
        );
        sculptureGroup.add(canopy);

        const pendants = [];
        for (let i = 0; i < profile.pendantCount; i += 1) {
          const phase = (i / profile.pendantCount) * Math.PI * 2;
          const radius = 0.4 + i * 0.11;
          const length = 0.9 + (i % 5) * 0.2;

          const pendant = new THREE.Group();
          pendant.position.set(Math.cos(phase) * radius, -0.03, Math.sin(phase) * radius);

          const wire = new THREE.Mesh(
            new THREE.CylinderGeometry(0.008, 0.008, length, 8),
            new THREE.MeshStandardMaterial({ color: '#b9bfc9', roughness: 0.4, metalness: 0.8 })
          );
          wire.position.y = -length / 2;
          pendant.add(wire);

          const bulb = new THREE.Mesh(
            new THREE.SphereGeometry(0.11, 16, 16),
            new THREE.MeshStandardMaterial({
              color: '#ffffff',
              emissive: '#d7e7ff',
              emissiveIntensity: 0.95,
              roughness: 0.2,
              metalness: 0.14,
            })
          );
          bulb.position.y = -length;
          pendant.add(bulb);

          let bulbLight = null;
          if (profile.enablePendantPointLights) {
            bulbLight = new THREE.PointLight('#dce8ff', 0.26, 3.2);
            bulbLight.position.y = -length;
            pendant.add(bulbLight);
          }

          pendants.push({
            group: pendant,
            baseX: pendant.position.x,
            baseY: pendant.position.y,
            baseZ: pendant.position.z,
            phase,
            material: bulb.material,
            light: bulbLight,
          });

          sculptureGroup.add(pendant);
        }

        const textureLoader = new THREE.TextureLoader();
        textureLoader.setCrossOrigin('anonymous');
        const frameMaterial = new THREE.MeshStandardMaterial({
          color: '#3a342c',
          roughness: 0.54,
          metalness: 0.22,
        });

        for (let index = 0; index < visibleImages.length; index += 1) {
          const data = visibleImages[index];
          const side = index % 2 === 0 ? -1 : 1;
          const row = Math.floor(index / 2);
          const z = corridorStart - row * step;

          const frameGroup = new THREE.Group();
          frameGroup.position.set(side * (wallHalf - 0.14), 2.7, z);
          frameGroup.rotation.y = side === -1 ? Math.PI / 2 : -Math.PI / 2;

          const frameOuter = new THREE.Mesh(new THREE.BoxGeometry(3.2, 2.34, 0.16), frameMaterial.clone());
          frameOuter.position.z = -0.05;
          frameGroup.add(frameOuter);

          const artMaterial = new THREE.MeshBasicMaterial({
            color: '#1d1d1d',
          });
          const artMesh = new THREE.Mesh(new THREE.PlaneGeometry(2.98, 2.02), artMaterial);
          artMesh.position.z = 0.04;
          frameGroup.add(artMesh);

          textureLoader.load(
            toProxyImageUrl(data.imageUrl),
            (texture) => {
              const width = texture.image?.naturalWidth || texture.image?.width || 1;
              const height = texture.image?.naturalHeight || texture.image?.height || 1;
              const ratio = THREE.MathUtils.clamp(width / Math.max(height, 1), 0.65, 1.85);
              const pictureHeight = 1.98;
              const pictureWidth = pictureHeight * ratio;

              texture.colorSpace = THREE.SRGBColorSpace;
              texture.anisotropy = textureAnisotropy;
              texture.needsUpdate = true;

              artMesh.geometry.dispose();
              artMesh.geometry = new THREE.PlaneGeometry(pictureWidth, pictureHeight);
              artMaterial.map = texture;
              artMaterial.color = new THREE.Color('#ffffff');
              artMaterial.needsUpdate = true;
            },
            undefined,
            () => {
              artMaterial.color = new THREE.Color('#3f2e2e');
            }
          );

          const tagTexture = createTagTexture(data.title, data.location, data.date);
          if (tagTexture) {
            const tag = new THREE.Mesh(
              new THREE.PlaneGeometry(1.96, 0.42),
              new THREE.MeshBasicMaterial({
                map: tagTexture,
                transparent: true,
                opacity: 0.82,
              })
            );
            tag.position.set(0, -1.42, 0.06);
            tag.rotation.x = -0.03;
            frameGroup.add(tag);
          }

          if (profile.frameLightStride > 0 && index % profile.frameLightStride === 0) {
            const target = new THREE.Object3D();
            target.position.set(side * (wallHalf - 0.04), 2.66, z);
            scene.add(target);

            const frameLight = new THREE.SpotLight('#fff3d8', 0.78, 8.4, Math.PI / 8, 0.52);
            frameLight.position.set(side * (wallHalf - 1.9), ceilingHeight - 0.58, z + 0.25);
            frameLight.target = target;
            frameLight.castShadow = false;
            scene.add(frameLight);

            if (profile.enableLightPulsing) {
              animatedLights.push({
                material: null,
                light: frameLight,
                base: 0.78,
                phase: index * 0.3,
              });
            }
          }

          scene.add(frameGroup);
        }

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const movement = {
          forward: false,
          backward: false,
          left: false,
          right: false,
          sprint: false,
        };

        let rafId = 0;
        let previousTime = performance.now();
        const walkSpeedByTier = {
          low: 30,
          medium: 34,
          high: 38,
        };
        const walkSpeed = walkSpeedByTier[profile.tier] || 34;
        const sprintMultiplier = 1.55;
        const minX = -5.8;
        const maxX = 5.8;
        const minZ = corridorEnd + 2.4;
        const maxZ = corridorStart + 2.2;

        const onKeyDown = (event) => {
          switch (event.code) {
            case 'KeyW':
            case 'ArrowUp':
              movement.forward = true;
              break;
            case 'KeyS':
            case 'ArrowDown':
              movement.backward = true;
              break;
            case 'KeyA':
            case 'ArrowLeft':
              movement.left = true;
              break;
            case 'KeyD':
            case 'ArrowRight':
              movement.right = true;
              break;
            case 'ShiftLeft':
            case 'ShiftRight':
              movement.sprint = true;
              break;
            default:
              break;
          }
        };

        const onKeyUp = (event) => {
          switch (event.code) {
            case 'KeyW':
            case 'ArrowUp':
              movement.forward = false;
              break;
            case 'KeyS':
            case 'ArrowDown':
              movement.backward = false;
              break;
            case 'KeyA':
            case 'ArrowLeft':
              movement.left = false;
              break;
            case 'KeyD':
            case 'ArrowRight':
              movement.right = false;
              break;
            case 'ShiftLeft':
            case 'ShiftRight':
              movement.sprint = false;
              break;
            default:
              break;
          }
        };

        const onResize = () => {
          camera.aspect = container.clientWidth / container.clientHeight;
          camera.updateProjectionMatrix();
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, profile.pixelRatioCap));
          renderer.setSize(container.clientWidth, container.clientHeight);
        };

        controls.addEventListener('lock', () => {
          authPanel.classList.add('hidden');
          artistsPanel.classList.add('hidden');
          controlsHint.textContent = 'Press Esc to leave';
          controlsHint.classList.remove('hidden');
          enterButton.classList.add('hidden');
        });

        controls.addEventListener('unlock', () => {
          authPanel.classList.remove('hidden');
          artistsPanel.classList.remove('hidden');
          controlsHint.classList.add('hidden');
          enterButton.classList.remove('hidden');
        });

        const animate = () => {
          rafId = window.requestAnimationFrame(animate);

          const time = performance.now();
          const delta = (time - previousTime) / 1000;

          if (controls.isLocked) {
            velocity.x -= velocity.x * 8.5 * delta;
            velocity.z -= velocity.z * 8.5 * delta;
            direction.z = Number(movement.forward) - Number(movement.backward);
            direction.x = Number(movement.right) - Number(movement.left);
            direction.normalize();
            const movementSpeed = movement.sprint ? walkSpeed * sprintMultiplier : walkSpeed;

            if (movement.forward || movement.backward) {
              velocity.z -= direction.z * movementSpeed * delta;
            }

            if (movement.left || movement.right) {
              velocity.x -= direction.x * movementSpeed * delta;
            }

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            camera.position.x = THREE.MathUtils.clamp(camera.position.x, minX, maxX);
            camera.position.z = THREE.MathUtils.clamp(camera.position.z, minZ, maxZ);
            camera.position.y = 1.72;
          }

          if (profile.enableSceneAnimation || profile.enableLightPulsing) {
            const sceneTime = time * 0.001;

            if (profile.enableSceneAnimation) {
              sculptureGroup.rotation.y += delta * 0.1;
              for (const pendant of pendants) {
                pendant.group.position.x = pendant.baseX + Math.sin(sceneTime * 1.1 + pendant.phase) * 0.06;
                pendant.group.position.y = pendant.baseY + Math.sin(sceneTime * 1.8 + pendant.phase * 0.8) * 0.035;
                pendant.group.position.z = pendant.baseZ + Math.cos(sceneTime * 1.2 + pendant.phase) * 0.06;

                const glow = 0.8 + Math.sin(sceneTime * 2.1 + pendant.phase * 1.7) * 0.22;
                pendant.material.emissiveIntensity = glow;
                if (pendant.light) {
                  pendant.light.intensity = 0.18 + glow * 0.14;
                }
              }
            }

            if (profile.enableLightPulsing) {
              for (const dynamicLight of animatedLights) {
                const pulse = 0.84 + Math.sin(sceneTime * 1.4 + dynamicLight.phase) * 0.16;
                if (dynamicLight.material) {
                  dynamicLight.material.emissiveIntensity = dynamicLight.base * pulse;
                }
                if (dynamicLight.light) {
                  dynamicLight.light.intensity = dynamicLight.base * pulse;
                }
              }
            }
          } else {
            for (const pendant of pendants) {
              pendant.material.emissiveIntensity = 0.78;
              if (pendant.light) {
                pendant.light.intensity = 0.22;
              }
            }
          }

          previousTime = time;
          renderer.render(scene, camera);
        };

        window.addEventListener('resize', onResize);
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        animate();

        enterButton.onclick = () => controls.lock();

        return () => {
          window.cancelAnimationFrame(rafId);
          window.removeEventListener('resize', onResize);
          window.removeEventListener('keydown', onKeyDown);
          window.removeEventListener('keyup', onKeyUp);
          controls.disconnect();

          scene.traverse((object) => {
            if (!object.isMesh) return;
            if (object.geometry) object.geometry.dispose();

            if (Array.isArray(object.material)) {
              object.material.forEach((material) => disposeMaterial(material));
            } else {
              disposeMaterial(object.material);
            }
          });

          renderer.dispose();
          container.innerHTML = '';
        };
      }

      async function bootstrap() {
        loginButton.addEventListener('click', () => {
          setStatus('Redirecting to Spotify login...');
          startSpotifyLogin().catch((error) => {
            showError(error instanceof Error ? error.message : 'Spotify login failed.');
          });
        });

        if (!SPOTIFY_CLIENT_ID) {
          setStatus('Set PUBLIC_SPOTIFY_CLIENT_ID in your environment to enable Spotify login.');
          loginButton.disabled = true;
          return;
        }

        let token;
        try {
          token = await resolveSpotifyToken();
        } catch (error) {
          setStatus('Spotify authentication failed. Please try logging in again.');
          showError(error instanceof Error ? error.message : 'Authentication error');
          clearStoredAuth();
          return;
        }

        if (!token) {
          setStatus('Log in with Spotify to unlock your personalized gallery.');
          return;
        }

        loginButton.classList.add('hidden');
        setStatus('Loading your top Spotify artists...');

        let artists = [];
        try {
          artists = await loadTopArtists(token);
        } catch (error) {
          const isAuthIssue = error instanceof HttpError && error.status === 401;
          if (isAuthIssue) {
            clearStoredAuth();
          }

          setStatus('Could not read Spotify profile data. Please authenticate again.');
          showError(error instanceof Error ? error.message : 'Spotify API error');
          loginButton.classList.remove('hidden');
          return;
        }

        const artistNames = artists.slice(0, 40).map((artist) => artist.name);
        renderArtists(artists);
        artistsPanel.classList.remove('hidden');

        const performanceProfile = getPerformanceProfile();
        setStatus(`Curating and mounting your photo selection (${performanceProfile.label} mode)...`);

        let images = [];
        try {
          images = await loadGalleryImages(artistNames, performanceProfile);
        } catch (error) {
          setStatus('Could not load gallery images.');
          showError(error instanceof Error ? error.message : 'Gallery API error');
          return;
        }

        if (!images.length) {
          setStatus('No matching photos were found for this listening profile yet.');
          return;
        }

        disposeScene();
        disposeScene = initializeThreeScene(images, performanceProfile);
        enterButton.classList.remove('hidden');
        authPanel.classList.add('ready');
        setStatus('Gallery ready. Click "Enter Gallery" to explore in first person.');
      }

      bootstrap().catch((error) => {
        showError(error instanceof Error ? error.message : 'Unexpected startup error.');
      });

      window.addEventListener('beforeunload', () => {
        disposeScene();
      });
    </script>
  </body>
</html>

<style>
  :global(html),
  :global(body) {
    margin: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: radial-gradient(circle at 16% 14%, #f2f0eb 0%, #dddad2 60%, #d2cdc3 100%);
    color: #222019;
    font-family: 'Trebuchet MS', 'Gill Sans', 'Segoe UI', sans-serif;
  }

  #gallery-app {
    position: relative;
    width: 100vw;
    height: 100vh;
    background:
      radial-gradient(circle at 82% 80%, rgb(186 150 108 / 18%), transparent 44%),
      radial-gradient(circle at 8% 16%, rgb(171 191 224 / 18%), transparent 36%);
  }

  #scene-root {
    width: 100%;
    height: 100%;
  }

  .overlay-panel {
    position: absolute;
    left: 1.5rem;
    top: 1.5rem;
    width: min(25rem, calc(100vw - 3rem));
    padding: 1rem 1.05rem 0.9rem;
    border-radius: 0.95rem;
    border: 1px solid rgb(32 30 24 / 13%);
    background: linear-gradient(160deg, rgb(255 255 255 / 74%), rgb(246 243 235 / 66%));
    backdrop-filter: blur(4px);
    box-shadow: 0 14px 28px rgb(0 0 0 / 13%);
    z-index: 30;
    transition: opacity 300ms ease, transform 300ms ease;
  }

  .overlay-panel.ready {
    opacity: 0.44;
    transform: translateY(-0.2rem);
  }

  .kicker {
    margin: 0;
    font-size: 0.72rem;
    text-transform: uppercase;
    letter-spacing: 0.16em;
    color: rgb(88 74 46 / 84%);
  }

  .overlay-panel h1 {
    margin: 0.4rem 0 0.72rem;
    font-size: clamp(1.2rem, 2.6vw, 1.65rem);
    line-height: 1.2;
    font-family: Georgia, 'Times New Roman', serif;
    color: #322c22;
  }

  #status-text {
    margin: 0;
    line-height: 1.42;
    color: rgb(63 58 49 / 87%);
  }

  .cta-button {
    margin-top: 1rem;
    border: 0;
    border-radius: 999px;
    padding: 0.74rem 1.15rem;
    font-size: 0.95rem;
    font-weight: 700;
    cursor: pointer;
    color: #1e1810;
    background: linear-gradient(150deg, #f4dca1, #dcad73);
    transition: transform 180ms ease, box-shadow 180ms ease;
    box-shadow: 0 8px 24px rgb(255 175 110 / 34%);
  }

  .cta-button:hover:enabled {
    transform: translateY(-1px);
  }

  .cta-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .meta-note {
    margin: 0.85rem 0 0;
    font-size: 0.8rem;
    color: rgb(98 90 73 / 84%);
  }

  .enter-button {
    position: absolute;
    left: 50%;
    bottom: 2.2rem;
    transform: translateX(-50%);
    border: 1px solid rgb(49 40 29 / 36%);
    border-radius: 999px;
    padding: 0.9rem 1.3rem;
    background: linear-gradient(120deg, rgb(249 244 234 / 94%), rgb(231 222 205 / 88%));
    color: #2f261b;
    font-size: 0.95rem;
    font-weight: 700;
    cursor: pointer;
    z-index: 35;
  }

  .artists-panel {
    position: absolute;
    right: 1.25rem;
    top: 1.25rem;
    width: min(16rem, calc(100vw - 2.5rem));
    padding: 0.6rem 0.75rem;
    border-radius: 0.9rem;
    border: 1px solid rgb(38 35 27 / 16%);
    background: linear-gradient(165deg, rgb(255 255 255 / 60%), rgb(244 241 233 / 56%));
    z-index: 30;
    max-height: min(78vh, 34rem);
    overflow: auto;
    opacity: 0.78;
  }

  .panel-title {
    margin: 0;
    font-size: 0.72rem;
    text-transform: uppercase;
    letter-spacing: 0.16em;
    color: rgb(95 79 50 / 88%);
  }

  #artists-list {
    margin: 0.65rem 0 0;
    padding: 0;
    list-style: none;
    display: grid;
    gap: 0.4rem;
  }

  #artists-list li {
    border: 1px solid rgb(33 28 21 / 10%);
    border-radius: 0.6rem;
    padding: 0.36rem 0.48rem;
    font-size: 0.83rem;
    background: rgb(252 251 248 / 72%);
    color: rgb(57 49 37 / 94%);
  }

  .controls-hint {
    position: absolute;
    left: 50%;
    bottom: 1rem;
    transform: translateX(-50%);
    margin: 0;
    border-radius: 999px;
    padding: 0.52rem 0.86rem;
    background: rgb(250 246 236 / 78%);
    color: #3b2f1f;
    font-size: 0.8rem;
    letter-spacing: 0.02em;
    z-index: 35;
  }

  .error-toast {
    position: absolute;
    left: 50%;
    top: 1rem;
    transform: translateX(-50%);
    width: min(90vw, 32rem);
    border-radius: 0.8rem;
    border: 1px solid rgb(255 136 136 / 48%);
    padding: 0.6rem 0.8rem;
    background: rgb(54 11 16 / 89%);
    color: #ffe4e4;
    font-size: 0.86rem;
    z-index: 45;
  }

  .hidden {
    display: none !important;
  }

  @media (max-width: 860px) {
    .overlay-panel {
      top: 0.85rem;
      left: 0.85rem;
      width: calc(100vw - 1.7rem);
    }

    .artists-panel {
      top: auto;
      bottom: 4.5rem;
      left: 0.85rem;
      right: 0.85rem;
      width: auto;
      max-height: 32vh;
    }

    .controls-hint {
      width: calc(100vw - 1.7rem);
      border-radius: 0.72rem;
      text-align: center;
      bottom: 0.95rem;
      line-height: 1.35;
    }

    .enter-button {
      bottom: 1rem;
    }
  }
</style>
